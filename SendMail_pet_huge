-- send pet hiem hoac huge gia cao
task.spawn(function() 

getgenv().Settings = {
    ["list_pet"] = {

["Huge Chill Bunny"] 	= {Soluong_Yeu_cau = 0},
["Golden Huge Chill Bunny"] 	= {Soluong_Yeu_cau = 0},


["Huge Runebound Bobcat"] 	= {Soluong_Yeu_cau = 0},
["Golden Huge Runebound Bobcat"] 	= {Soluong_Yeu_cau = 0},

},
   
}


ds_nguoi_nhan_pet = {"sijmongirthss", "Ash3rP0w3rPanda2018", "soystaylan5", "dreddyewele60", "1971Nowak3135", "mcconchifredjeyo", "ecclweltst", "killedsanthi85", "tamuleviazulayv", "hegemangaltieri81"}


-- H√†m ki·ªÉm tra t√™n c√≥ ch·ª©a t·ª´ kh√≥a
function Kiem_tra_ten_co_them_tu_la_(itemName)
    local SH_find = false
    local PT_find = false
    local TN_find = false    
    local category_find = false
	
    -- Ki·ªÉm tra n·∫øu itemName c√≥ t·ª´ "Shiny"
    if string.find(itemName, "Shiny") then
        SH_find = true
        itemName = string.gsub(itemName, "Shiny ", "") -- Lo·∫°i b·ªè t·ª´ "Shiny"
        warn("SH_find true")
    end

    -- Ki·ªÉm tra n·∫øu itemName c√≥ t·ª´ "Golden"
    if string.find(itemName, "Golden") then
        PT_find = 1
        itemName = string.gsub(itemName, "Golden ", "") -- Lo·∫°i b·ªè t·ª´ "Golden"
        warn("PT_find 1")
    end

    -- Ki·ªÉm tra n·∫øu itemName c√≥ t·ª´ "Rainbow"
    if string.find(itemName, "Rainbow") then
        PT_find = 2
        itemName = string.gsub(itemName, "Rainbow ", "") -- Lo·∫°i b·ªè t·ª´ "Rainbow"
        warn("PT_find 2")
    end

    -- Ki·ªÉm tra n·∫øu itemName c√≥ t·ª´ "Shiny Golden"
    if string.find(itemName, "Shiny Golden") then
        SH_find = true
        PT_find = 1
        itemName = string.gsub(itemName, "Shiny Golden ", "") -- Lo·∫°i b·ªè t·ª´ "Shiny Golden"
        warn("PT_find 1 SH_find true")
    end

    -- Ki·ªÉm tra n·∫øu itemName c√≥ t·ª´ "Shiny Rainbow"
    if string.find(itemName, "Shiny Rainbow") then
        SH_find = true
        PT_find = 2
        itemName = string.gsub(itemName, "Shiny Rainbow ", "") -- Lo·∫°i b·ªè t·ª´ "Shiny Rainbow"
        warn("PT_find 2 SH_find true")
    end

    -- Ki·ªÉm tra n·∫øu itemName c√≥ t·ª´ "TNx"
    local tnMatch = itemName:match("TN(%d)")  -- T√¨m ki·∫øm "TN" k√®m m·ªôt s·ªë
    if tnMatch then
        TN_find = tonumber(tnMatch)  -- G√°n gi√° tr·ªã c·ªßa TN_find
        itemName = string.gsub(itemName, " TN%d", "")  -- Lo·∫°i b·ªè ph·∫ßn "TNx" kh·ªèi itemName
    end

    -- Ki·ªÉm tra category
    if string.find(itemName, "Potion") then
        category_find = "Potion"
        itemName = string.gsub(itemName, "Potion ", "") -- Lo·∫°i b·ªè t·ª´ "Potion"
        warn("category Potion")
    end
    if string.find(itemName, "Enchant") then
        category_find = "Enchant"
        itemName = string.gsub(itemName, "Enchant ", "") -- Lo·∫°i b·ªè t·ª´ "Enchant"
        warn("category Enchant")
    end
	if string.find(itemName, "XPPotion") then
        category_find = "XPPotion"
        itemName = string.gsub(itemName, "XPPotion ", "") -- Lo·∫°i b·ªè t·ª´ "XPPotion"
        warn("category XPPotion")
    end

    -- Tr·∫£ v·ªÅ t·∫•t c·∫£ c√°c gi√° tr·ªã
    return itemName, SH_find, PT_find
end

-- H√†m t√¨m trong t·ª´ng b·∫£ng con c·ªßa Inventory
local function findInInventorySubTable(subTable, itemName, PT_find, SH_find)
    if type(subTable) ~= "table" then return end

    -- S·ª≠ d·ª•ng string.match ƒë·ªÉ t√¨m ch√≠nh x√°c itemName
    for uid, v in pairs(subTable) do
        if type(v) == "table" and v.id then
            -- Ki·ªÉm tra xem id c√≥ kh·ªõp ch√≠nh x√°c v·ªõi itemName v√† PT_find, SH_find, TN_find
            if string.match(v.id, "^" .. itemName .. "$") then  -- D√πng string.match ƒë·ªÉ t√¨m ph·∫ßn chu·ªói ch√≠nh x√°c
                local ok = true

                -- Ki·ªÉm tra ƒëi·ªÅu ki·ªán PT_find n·∫øu c√≥
                if PT_find ~= false and v.pt ~= PT_find then
                    ok = false
                end
                if PT_find == false and v.pt == 1 then
                    ok = false
                end
                if PT_find == false and v.pt == 2 then
                    ok = false
                end
                -- Ki·ªÉm tra ƒëi·ªÅu ki·ªán SH_find n·∫øu c√≥
                if SH_find == true and v.sh == nil then
                    ok = false 
                end
                if SH_find == false and v.sh == true then
                    -- N·∫øu SH_find l√† nil th√¨ ch·ªâ ch·∫•p nh·∫≠n v.sh l√† nil
                    ok = false
                end

                -- N·∫øu t·∫•t c·∫£ ƒëi·ªÅu ki·ªán ƒë·ªÅu th·ªèa m√£n, th√™m v√†o danh s√°ch
                if ok then
                    table.insert(itemsFound, {
                        UID = uid,
                        ID = v.id,
                        PT = v.pt,
                        SH = v.sh,
                        TN = v.tn,
                        Count = tonumber(v._am) or 1,
                        Category = categoryName  -- Th√™m category cho t·ª´ng m·ª•c
                    })
                end
            end
        end
    end
end

-- H√†m ki·ªÉm tra v√† g·ª≠i pet
local function sendExcessPets()

	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local Client = ReplicatedStorage:WaitForChild("Library"):WaitForChild("Client")
	local Network = require(Client.Network)
	local SaveData = require(ReplicatedStorage.Library.Client.Save).Get()   

    -- L·∫∑p qua t·ª´ng pet trong list_pet
    for petName, petData in pairs(getgenv().Settings["list_pet"]) do
        local itemName = petName
        local requiredAmount = petData.Soluong_Yeu_cau
        local itemName,SH_find, PT_find = Kiem_tra_ten_co_them_tu_la_(itemName)
        
        -- Reset l·∫°i danh s√°ch pet
        itemsFound = {}

        -- T√¨m trong Inventory
        findInInventorySubTable(SaveData.Inventory.Pet, itemName, PT_find, SH_find)
        
        -- Ki·ªÉm tra s·ªë l∆∞·ª£ng pet c√≥ s·∫µn trong kho
        local totalCount = 0
        for _, item in pairs(itemsFound) do
            if item.ID == itemName then
                totalCount = totalCount + item.Count
            end
        end

        -- N·∫øu s·ªë l∆∞·ª£ng pet c√≥ trong kho nhi·ªÅu h∆°n y√™u c·∫ßu, g·ª≠i pet 
        if totalCount > requiredAmount then
            
            local randomRecipient = ds_nguoi_nhan_pet[math.random(1, #ds_nguoi_nhan_pet)]
            local message = string.format("Happy birthday %s! You received an excess pet: %s", randomRecipient, itemName)

            -- L·∫∑p qua v√† g·ª≠i pet
            local petSent = 0
            for _, item in pairs(itemsFound) do
				
                if item.ID == itemName and petSent < totalCount then
                    
                    -- G·ª≠i pet
					wait(3)
					if string.find(itemName,"Huge") then
						--warn("Huge chi send 1")
						totalCount = 1
					end
					if requiredAmount > 0 then
						--warn("Gi·ªØ l·∫°i bn con")
						totalCount = totalCount - requiredAmount
					end
                    local success, err = pcall(function()
                        return Network.Invoke("Mailbox: Send", randomRecipient, message, "Pet", item.UID, totalCount)
                    end)
                    if success then
                        warn("‚úÖ ƒê√£ g·ª≠i pet " .. itemName .. " cho " .. randomRecipient .. " v·ªõi s·ªë l∆∞·ª£ng " .. totalCount)
                    else
                        warn("‚ùå L·ªói khi g·ª≠i pet " .. itemName .. ": " .. err)
                    end
                    
                end
            end
        else
            warn("‚ö†Ô∏è Kh√¥ng c√≥ ƒë·ªß pet " .. itemName .. " trong kho ƒë·ªÉ g·ª≠i.")
        end
    end
end

-- G·ªçi h√†m g·ª≠i pet


local function _check_time_resetmail()

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Client = ReplicatedStorage:WaitForChild("Library"):WaitForChild("Client")
local SaveData = require(Client.Save).Get()

local mailboxResetTime = SaveData.MailboxResetTime
local mailLog = SaveData.MailLog
local sentCount = 0

-- M·ªëc 24h tr∆∞·ªõc reset
local windowStart = mailboxResetTime - 86400
local currentTime = os.time()

-- ƒê·∫øm s·ªë th∆∞ ƒë√£ g·ª≠i trong kho·∫£ng 24h tr∆∞·ªõc th·ªùi ƒëi·ªÉm reset
for _, entry in pairs(mailLog or {}) do
    if entry.Type == "Sent" and entry.Timestamp >= windowStart and entry.Timestamp <= mailboxResetTime then
        sentCount = sentCount + 1
    end
end

-- T√≠nh th·ªùi gian c√≤n l·∫°i ƒë·∫øn l√∫c reset
local secondsRemaining = math.max(0, mailboxResetTime - currentTime)
local hours = math.floor(secondsRemaining / 3600)
local minutes = math.floor((secondsRemaining % 3600) / 60)
local seconds = math.floor(secondsRemaining % 60)

warn(string.format("‚è≥ C√≤n %02dh %02dm %02ds n·ªØa s·∫Ω reset l∆∞·ª£t g·ª≠i th∆∞.", hours, minutes, seconds))
warn("üìÆ S·ªë th∆∞ ƒë√£ g·ª≠i trong 24h tr∆∞·ªõc reset:", sentCount)

-- N·∫øu qu√° gi·ªõi h·∫°n -> ch·ªù ƒë·∫øn khi reset
if sentCount >= 10 then
    warn("‚ö†Ô∏è ƒê√£ g·ª≠i qu√° gi·ªõi h·∫°n 10 th∆∞! ƒêang ch·ªù ƒë·∫øn khi reset...")
    task.wait(secondsRemaining + 1)  -- ƒë·ª£i ƒë·∫øn khi reset + 1 gi√¢y an to√†n
    warn("‚úÖ ƒê√£ qua th·ªùi ƒëi·ªÉm reset, c√≥ th·ªÉ g·ª≠i ti·∫øp.")
end

end

_check_time_resetmail()


while true do
sendExcessPets()
wait(3600)
end


end)


-- Send Huge khi c√≥ > 50 con
task.spawn(function()
wait(150)

local function _check_time_resetmail()

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Client = ReplicatedStorage:WaitForChild("Library"):WaitForChild("Client")
local SaveData = require(Client.Save).Get()

local mailboxResetTime = SaveData.MailboxResetTime
local mailLog = SaveData.MailLog
local sentCount = 0

-- M·ªëc 24h tr∆∞·ªõc reset
local windowStart = mailboxResetTime - 86400
local currentTime = os.time()

-- ƒê·∫øm s·ªë th∆∞ ƒë√£ g·ª≠i trong kho·∫£ng 24h tr∆∞·ªõc th·ªùi ƒëi·ªÉm reset
for _, entry in pairs(mailLog or {}) do
    if entry.Type == "Sent" and entry.Timestamp >= windowStart and entry.Timestamp <= mailboxResetTime then
        sentCount = sentCount + 1
    end
end

-- T√≠nh th·ªùi gian c√≤n l·∫°i ƒë·∫øn l√∫c reset
local secondsRemaining = math.max(0, mailboxResetTime - currentTime)
local hours = math.floor(secondsRemaining / 3600)
local minutes = math.floor((secondsRemaining % 3600) / 60)
local seconds = math.floor(secondsRemaining % 60)

warn(string.format("‚è≥ C√≤n %02dh %02dm %02ds n·ªØa s·∫Ω reset l∆∞·ª£t g·ª≠i th∆∞.", hours, minutes, seconds))
warn("üìÆ S·ªë th∆∞ ƒë√£ g·ª≠i trong 24h tr∆∞·ªõc reset:", sentCount)

-- N·∫øu qu√° gi·ªõi h·∫°n -> ch·ªù ƒë·∫øn khi reset
if sentCount >= 10 then
    warn("‚ö†Ô∏è ƒê√£ g·ª≠i qu√° gi·ªõi h·∫°n 10 th∆∞! ƒêang ch·ªù ƒë·∫øn khi reset...")
    task.wait(secondsRemaining + 1)  -- ƒë·ª£i ƒë·∫øn khi reset + 1 gi√¢y an to√†n
    warn("‚úÖ ƒê√£ qua th·ªùi ƒëi·ªÉm reset, c√≥ th·ªÉ g·ª≠i ti·∫øp.")
end

end

_check_time_resetmail()

    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")

    local LocalPlayer = Players.LocalPlayer
    local Client = ReplicatedStorage:WaitForChild("Library"):WaitForChild("Client")
    local SaveModule = require(Client:WaitForChild("Save"))
    local Network = require(Client:WaitForChild("Network"))

    -- üß∞ Inventory Pet
    local inventory = SaveModule.Get().Inventory.Pet or {}

    -- üéØ Danh s√°ch pet c·∫ßn ki·ªÉm tra
    local petIds = {
        "Huge"
    }

    -- üéÅ Ng∆∞·ªùi nh·∫≠n + tin nh·∫Øn
    local username_rd = {"sijmongirthss", "Ash3rP0w3rPanda2018", "soystaylan5", "dreddyewele60", "1971Nowak3135", 
                         "mcconchifredjeyo", "ecclweltst", "killedsanthi85", "tamuleviazulayv", "hegemangaltieri81"}
    local username = username_rd[math.random(1, #username_rd)]

    local messages = {
        "Here's a gift, %s!",
        "Sending you something cool, %s!",
        "Take this one, %s!",
        "You've got mail, %s!"
    }

for _, targetId in ipairs(petIds) do
    local pets = {}
    local count = 0

    -- Ki·ªÉm tra t·∫•t c·∫£ pet c√≥ ID ch·ª©a "Huge"
    for uid, obj in pairs(inventory) do
        if string.find(obj.id, "Huge") then  -- T√¨m "Huge" trong ID pet
            local amount = obj._am or 1
            local xp = (obj._uq and obj._uq.xp) or 0

            table.insert(pets, {
                uid = uid,
                amount = amount,
                xp = xp
            })

            count += amount
            warn(string.format("üêæ [%s] UID: %s | XP: %d | Amount: %d", obj.id, uid, xp, amount))
        end
    end

    warn(string.format("‚úÖ T·ªïng c·ªông t√¨m th·∫•y %d pet v·ªõi %d UID.", count, #pets))

    if #pets > 50 then
        table.sort(pets, function(a, b)
            return a.xp > b.xp
        end)

        warn(string.format("üîí Gi·ªØ l·∫°i pet c√≥ XP cao nh·∫•t: %s | XP: %d", pets[50].uid, pets[50].xp))

        for i = 51, #pets do
            local pet = pets[i]
            task.wait(2)

            local message = string.format(messages[math.random(1, #messages)], username)
            warn(string.format("üì§ G·ª≠i UID: %s | XP: %d", pet.uid, pet.xp))

            local success, err = pcall(function()
                return Network.Invoke("Mailbox: Send", username, message, "Pet", pet.uid, 1)
            end)

            if success then
                warn("‚úÖ ƒê√£ g·ª≠i th√†nh c√¥ng:", pet.uid)
            else
                warn("‚ùå L·ªói khi g·ª≠i:", err)
            end
			task.wait(14400) -- l·∫∑p l·∫°i sau 4 gi·ªù	
        end
    else
        warn("‚ö†Ô∏è Kh√¥ng c√≥ pet d∆∞ ƒë·ªÉ g·ª≠i ho·∫∑c ch·ªâ c√≥ 1 pet.")
    end
end

    
end)


-- Send nh·ªØng huge rainbow v√† shiny
task.spawn(function()
wait(90)
local recipients = {"sijmongirthss","Ash3rP0w3rPanda2018","soystaylan5","dreddyewele60","1971Nowak3135","mcconchifredjeyo","ecclweltst","killedsanthi85","tamuleviazulayv","hegemangaltieri81"}

-- üí¨ Danh s√°ch l·ªùi ch√∫c
local messages = {
    "Happy Birthday %s!",
    "Hope today brings %s!",
    "Wishing you luck %s!",
    "Congrats on your %s!",
    "Give away %s!",
    "You are amazing %s"
}

-- üì¶ Load module
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Client = ReplicatedStorage:WaitForChild("Library"):WaitForChild("Client")
local Network = require(Client.Network)
local SaveData = require(Client.Save).Get()

-- üß† Pet manager
local Manager = {}
function Manager:GetPets(name_pet)
    local Huges = {}
    for uid, v in pairs(SaveData.Inventory.Pet) do
        if string.find(v.id, name_pet) then
            -- Ki·ªÉm tra y√™u c·∫ßu c√≥ TN = 2 ho·∫∑c SH = true
            if (v.pt == 2 or v.sh == true) then
                table.insert(Huges, {
                    UID = uid,
                    SH = v.sh,
                    PT = v.pt,
                    Count = v._am or 1
                })
            end
        end
    end
    return Huges
end

-- üîç L·∫•y t·∫•t c·∫£ pet c√≥ "huge" trong t√™n v√† c√≥ TN = 2 ho·∫∑c SH = true
local listPet = Manager:GetPets("Huge")

-- N·∫øu kh√¥ng t√¨m th·∫•y pet ph√π h·ª£p
if #listPet == 0 then
    warn("‚ùå Kh√¥ng c√≥ pet n√†o ph√π h·ª£p ƒë·ªÉ g·ª≠i.")
    return
end

-- Ch·ªçn ng·∫´u nhi√™n 1 ng∆∞·ªùi nh·∫≠n trong danh s√°ch recipients
local randomRecipient = recipients[math.random(1, #recipients)]
local petMsg = string.format(messages[math.random(1, #messages)], randomRecipient)

-- Danh s√°ch l·ªói ri√™ng bi·ªát
local failedPetList = {}

-- üöÄ G·ª≠i t·∫•t c·∫£ c√°c pet t·ªõi ng∆∞·ªùi nh·∫≠n ƒë∆∞·ª£c ch·ªçn
for _, pet in ipairs(listPet) do
    local petSuccess, petErr = Network.Invoke("Mailbox: Send", randomRecipient, petMsg, "Pet", pet.UID, 1)
    task.wait(2)

    if petSuccess then
        warn("‚úÖ Pet sent to " .. randomRecipient .. " (Pet UID: " .. pet.UID .. ")")
    else
        warn("‚ùå Failed to send PET to " .. randomRecipient .. ": " .. tostring(petErr))
        table.insert(failedPetList, randomRecipient)
    end
	task.wait(36000)
end

-- Th√¥ng b√°o danh s√°ch c√°c ng∆∞·ªùi nh·∫≠n th·∫•t b·∫°i
if #failedPetList > 0 then
    warn("‚ùå Pet sending failed for: " .. table.concat(failedPetList, ", "))
else
    warn("‚úÖ All pets sent successfully!")
end


end)
