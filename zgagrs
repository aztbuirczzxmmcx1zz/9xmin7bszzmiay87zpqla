# pip install keyboard
# C·∫ßn Windows OS ƒë·ªÉ h√†m ctypes ho·∫°t ƒë·ªông

import time
import threading
import keyboard
import os
import shutil
import subprocess
import os 
from time import sleep # Import sleep r√µ r√†ng h∆°n
import ctypes

# C·∫•u h√¨nh ƒë∆∞·ªùng d·∫´n
DATA_FOLDER = r"C:\Users\ADMIN\Downloads\Yummyemu\YummyEmuPlayer\ChangeAcc"
EMURB_PATH = r"C:\Users\ADMIN\Downloads\Yummyemu\YummyEmuPlayer\EmuRB.exe"
EMURB_PROCESS_NAME = "EmuRB.exe"

# Bi·∫øn ki·ªÉm so√°t tr·∫°ng th√°i
running = False
thread = None
action_thread = None

# ===============================================
#   C·∫§U TR√öC CHO WriteConsoleInputW (Windows API)
#   Ph∆∞∆°ng ph√°p nh·∫≠p m·ªõi - KH√îNG C·∫¶N FOCUS
# ===============================================

kernel32 = ctypes.windll.kernel32

# Event type
KEY_EVENT = 0x0001
# STD_INPUT_HANDLE = -10 (0xFFFFFFF6)
VK_RETURN = 0x0D # Virtual Key Code cho ph√≠m Enter

class KEY_EVENT_RECORD(ctypes.Structure):
    _fields_ = [
        ("bKeyDown", ctypes.c_int),
        ("wRepeatCount", ctypes.c_uint16),
        ("wVirtualKeyCode", ctypes.c_uint16),
        ("wVirtualScanCode", ctypes.c_uint16),
        ("uChar", ctypes.c_wchar),
        ("dwControlKeyState", ctypes.c_uint32)
    ]

class INPUT_RECORD(ctypes.Structure):
    _fields_ = [
        ("EventType", ctypes.c_uint16),
        ("KeyEvent", KEY_EVENT_RECORD)
    ]

# Thi·∫øt l·∫≠p ki·ªÉu tr·∫£ v·ªÅ v√† ƒë·ªëi s·ªë cho c√°c h√†m WinAPI (ƒê·∫£m b·∫£o an to√†n)
kernel32.GetStdHandle.restype = ctypes.c_void_p
kernel32.WriteConsoleInputW.argtypes = (
    ctypes.c_void_p, 
    ctypes.POINTER(INPUT_RECORD), 
    ctypes.c_uint32, 
    ctypes.POINTER(ctypes.c_uint32)
)

def send_console_key(char):
    """G·ª≠i m·ªôt ph√≠m b·∫•t k·ª≥ (bao g·ªìm \r cho Enter) v√†o console buffer."""
    hIn = kernel32.GetStdHandle(-10)  # STD_INPUT_HANDLE = -10

    # L·∫•y VK Code v√† char cho Enter
    if char == "\r":
        vk_code = VK_RETURN
        u_char = "\r"
    else:
        # L·∫•y VK Code v√† char cho k√Ω t·ª± th∆∞·ªùng
        vk_code = ord(char.upper())
        u_char = char

    record = INPUT_RECORD()
    record.EventType = KEY_EVENT

    # 1. Key down
    record.KeyEvent = KEY_EVENT_RECORD(
        bKeyDown=1,
        wRepeatCount=1,
        wVirtualKeyCode=vk_code,
        wVirtualScanCode=0,
        uChar=u_char,
        dwControlKeyState=0
    )
    bytes_written = ctypes.c_uint32(0)
    kernel32.WriteConsoleInputW(hIn, ctypes.byref(record), 1, ctypes.byref(bytes_written))

    # 2. Key up
    record.KeyEvent.bKeyDown = 0
    kernel32.WriteConsoleInputW(hIn, ctypes.byref(record), 1, ctypes.byref(bytes_written))
    
    # Ngh·ªâ ng·∫Øn ƒë·ªÉ console x·ª≠ l√Ω input
    time.sleep(0.1)

def send_enter():
    send_console_key("\r")

# ===============================================
# LOGIC V√íNG L·∫∂P (Gi·ªØ nguy√™n)
# ===============================================

# ‚úÖ H√†m x√≥a file trong th∆∞ m·ª•c
def clear_folder(folder_path):
    print(f"\nüîÑ X√≥a c√°c file trong th∆∞ m·ª•c: {folder_path}")
    if not os.path.isdir(folder_path):
        print(f"‚ùå L·ªói: Th∆∞ m·ª•c kh√¥ng t·ªìn t·∫°i: {folder_path}")
        return
    try:
        for filename in os.listdir(folder_path):
            file_path = os.path.join(folder_path, filename)
            if os.path.isfile(file_path):
                os.remove(file_path)
        print(f"‚úÖ ƒê√£ x√≥a ho√†n t·∫•t c√°c file trong {folder_path}")
    except Exception as e:
        print(f"‚ùå L·ªói khi x√≥a file: {e}")

# ‚úÖ H√†m ƒë√≥ng ·ª©ng d·ª•ng
def close_application(process_name):
    print(f"üîÑ ƒê√≥ng ·ª©ng d·ª•ng: {process_name}")
    try:
        subprocess.run(
            f"taskkill /IM {process_name} /F",
            check=True,
            shell=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        print(f"‚úÖ ƒê√£ g·ª≠i l·ªánh ƒë√≥ng cho {process_name}")
    except:
        print(f"   Th√¥ng b√°o: ·ª®ng d·ª•ng {process_name} c√≥ th·ªÉ kh√¥ng ch·∫°y ho·∫∑c ƒë√£ ƒë√≥ng.")

# ‚úÖ H√†m m·ªü ·ª©ng d·ª•ng (Ph∆∞∆°ng ph√°p c≈© ƒë√£ ho·∫°t ƒë·ªông)
def open_application(app_path):
    print(f"üîÑ M·ªü ·ª©ng d·ª•ng: {app_path}")
    if not os.path.isfile(app_path):
        print(f"‚ùå L·ªói: File ·ª©ng d·ª•ng kh√¥ng t·ªìn t·∫°i: {app_path}")
        return

    # L·∫•y th∆∞ m·ª•c ch·ª©a file EmuRB.exe
    app_directory = os.path.dirname(app_path)
    
    try:
        # Popen ƒë∆°n gi·∫£n ƒë·ªÉ ·ª©ng d·ª•ng m·ªü v√† nh·∫≠n lu·ªìng I/O m·∫∑c ƒë·ªãnh
        subprocess.Popen([app_path], cwd=app_directory)
        print(f"‚úÖ ƒê√£ m·ªü ·ª©ng d·ª•ng: {app_path}")
    except Exception as e:
        print(f"‚ùå L·ªói khi m·ªü ·ª©ng d·ª•ng: {e}")

# ‚úÖ H√†m th·ª±c hi·ªán chu·ªói h√†nh ƒë·ªông (1 l·∫ßn)
def execute_single_action_sequence():
    print("----------------------------------------")
    print("‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu chu·ªói h√†nh ƒë·ªông...")

    # 1. ƒê·∫øm ng∆∞·ª£c 1440 ph√∫t (24h)
    # 1440 l√† s·ªë ph√∫t trong 24 gi·ªù. V√≤ng l·∫∑p n√†y ch·ªù 24 gi·ªù.
    for i in range(3, 0, -1):
        if not running: return # Tho√°t n·∫øu ƒë√£ b·∫•m STOP
        # Hi·ªÉn th·ªã th·ªùi gian c√≤n l·∫°i theo ph√∫t
        print(f"\r‚è≥ C√≤n l·∫°i {i} ph√∫t...", end='', flush=True) 
        sleep(1) # Ch·ªù 60 gi√¢y (1 ph√∫t)

    print("\n‚è≥ ƒê√£ k·∫øt th√∫c ƒë·∫øm ng∆∞·ª£c 24h.")
    
    # 2. Xo√° h·∫øt c√°c file trong C/yumi/data/
    if not running: return
    clear_folder(DATA_FOLDER)
    sleep(1) 

    # 3. ƒê√≥ng ·ª©ng d·ª•ng EmuRB.exe r·ªìi ch·ªù 10s
    if not running: return
    close_application(EMURB_PROCESS_NAME)
    print("‚è≥ Ch·ªù 10 gi√¢y sau khi ƒë√≥ng ·ª©ng d·ª•ng...")
    sleep(10)

    # 4. M·ªü l·∫°i ·ª©ng d·ª•ng EmuRB.exe r·ªìi ch·ªù 15s
    if not running: return
    open_application(EMURB_PATH)
    print("‚è≥ Ch·ªù 15 gi√¢y sau khi m·ªü ·ª©ng d·ª•ng...")
    sleep(15)

    # 5. Th·ª±c hi·ªán n√∫t b·∫•m s·ªë 2 ngh·ªâ 2s r·ªìi nh·∫•n ph√≠m Enter
    # S·ª¨ D·ª§NG PH∆Ø∆†NG PH√ÅP NH·∫¨P M·ªöI (ctypes)
    if not running: return
    print("üîÑ G·ª≠i ph√≠m '2' (Console Input)")
    send_console_key('2')
    print("‚è≥ Ch·ªù 2 gi√¢y...")
    sleep(2)
    print("üîÑ G·ª≠i ph√≠m 'Enter' (Console Input)")
    send_enter()

    print("\n‚úÖ ƒê√£ ho√†n th√†nh 1 chu tr√¨nh.")

# ‚úÖ V√≤ng l·∫∑p ch√≠nh - S·∫Ω ch·∫°y li√™n t·ª•c khi running=True
def run_loop():
    while running:
        try:
            execute_single_action_sequence()
            # Th√™m m·ªôt ch√∫t ngh·ªâ gi·ªØa c√°c v√≤ng l·∫∑p (v√≠ d·ª• 5 gi√¢y) ƒë·ªÉ d·ªÖ theo d√µi
            if running:
                print("--- B·∫Øt ƒë·∫ßu chu tr√¨nh m·ªõi sau 5 gi√¢y ---")
                sleep(5) 
        except Exception as e:
            print(f"‚ùå L·ªói trong v√≤ng l·∫∑p: {e}")
            sleep(5) # Ngh·ªâ ƒë·ªÉ tr√°nh l·∫∑p l·ªói nhanh

# ‚úÖ H√†m START/STOP (Gi·ªØ nguy√™n)
def start_loop():
    global running, thread
    if not running:
        print("\n========================================")
        print("üöÄ Script START - B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p t·ª± ƒë·ªông.")
        print("========================================")
        running = True
        # B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p trong m·ªôt thread m·ªõi
        thread = threading.Thread(target=run_loop)
        thread.start()
    else:
        print("‚ö†Ô∏è V√≤ng l·∫∑p ƒëang ch·∫°y r·ªìi!")

def stop_loop():
    global running
    if running:
        print("\n========================================")
        print("üõë Script STOP - D·ª´ng v√≤ng l·∫∑p.")
        print("========================================")
        running = False

# ===============================================
# MAIN
# ===============================================

# ‚úÖ B·∫Øt ph√≠m t·∫Øt
print("----------------------------------------")
print("üéõÔ∏è ƒêang ch·ªù ph√≠m t·∫Øt...")
print("üëâ Ctrl + 1 ƒë·ªÉ START v√≤ng l·∫∑p.")
print("üëâ Ctrl + 2 ƒë·ªÉ STOP v√≤ng l·∫∑p.")
print("üëâ Esc ƒë·ªÉ THO√ÅT script.")
print("----------------------------------------")

keyboard.add_hotkey('ctrl+1', start_loop)
keyboard.add_hotkey('ctrl+2', stop_loop)
keyboard.wait('esc')
print("‚èπÔ∏è Script ƒë√£ d·ª´ng ho√†n to√†n.")
