local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Client = ReplicatedStorage:WaitForChild("Library"):WaitForChild("Client")
local SaveData = require(Client.Save).Get()

local Enchants_Equip = ReplicatedStorage.Network.Enchants_Equip
local Enchants_ClearSlot = ReplicatedStorage.Network.Enchants_ClearSlot

-- Gom stack theo bookName v√† sort theo tn gi·∫£m d·∫ßn
local function getBookStackListFull(bookName)
    local stacks = {}

    for uid, v in pairs(SaveData.Inventory.Enchant) do
        if v.id and string.find(v.id, bookName) and (v._am or 1) > 0 then
            table.insert(stacks, {
                uid = uid,
                tn = v.tn or 0,
                amount = v._am or 1
            })
        end
    end

    table.sort(stacks, function(a, b)
        return a.tn > b.tn
    end)

    return stacks
end

function autoEquipEnchantBooks(bookList)
    local MaxEnchantsEquipped = SaveData.MaxEnchantsEquipped

    -- Clear all slots
    for i = 1, 9 do
        Enchants_ClearSlot:FireServer(i)
        task.wait(0.3)
    end

    local equippedCount = 0

    -- ƒê·∫øm s·ªë l∆∞·ª£ng m·ªói bookName ƒë∆∞·ª£c y√™u c·∫ßu
    local requestedCounts = {}
    for _, bookName in ipairs(bookList) do
        requestedCounts[bookName] = (requestedCounts[bookName] or 0) + 1
    end

    for bookName, requestCount in pairs(requestedCounts) do
        if equippedCount >= MaxEnchantsEquipped then
            break
        end

        local stacks = getBookStackListFull(bookName)
        local countForThisBook = 0

        for _, stack in ipairs(stacks) do
            for n = 1, stack.amount do
                if equippedCount >= MaxEnchantsEquipped or countForThisBook >= requestCount then
                    break
                end

                Enchants_Equip:FireServer(stack.uid)
                equippedCount = equippedCount + 1
                countForThisBook = countForThisBook + 1
                task.wait(0.3)
            end
            if countForThisBook >= requestCount then
                break
            end
        end
    end
end


autoEquipEnchantBooks({"Breakable Mayhem","Criticals","Lucky Eggs","Diamonds","Treasure Hunter","Super Lightning","Diamonds","Huge Hunter","Tap Power"})

 
function _OFF_ON_pet()
	
end
 
-- map 269 event time trial
task.spawn(function()
wait(75)

_G.STOP_TIME_TRIAL = false


local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local Save = require(ReplicatedStorage.Library.Client.Save)
local ZoneCmds = require(ReplicatedStorage.Library.Client.ZoneCmds)

local lagFlag = false
local endFlag = false
local lagMonitorThread, increaseMonitorThread, monitor12minThread

-- üõ°Ô∏è L·∫•y HumanoidRootPart an to√†n
local function getHumanoidRootPart()
	local character = player.Character or player.CharacterAdded:Wait()
	if not character then return nil end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	local waitTime = 0
	while not hrp and waitTime < 5 do
		task.wait(0.5)
		waitTime += 0.5
		hrp = character:FindFirstChild("HumanoidRootPart")
	end

	return hrp
end

-- üìä H√†m ti·ªán √≠ch
local function getRunsUsed()
	local saveData = Save.Get()
	return saveData and saveData.TimeTrialStats and (saveData.TimeTrialStats.DailyRuns or 0) or 0
end

local function getRunsLeft()
	return 10 - getRunsUsed()
end

local function getTimeTrialPoints()
	local saveData = Save.Get()
	return saveData and saveData.TimeTrialStats and (saveData.TimeTrialStats.Points or 0) or 0
end

local function getTotalRuns()
	local saveData = Save.Get()
	return saveData and saveData.TimeTrialStats and (saveData.TimeTrialStats.TotalRuns or 0) or 0
end

-- üó∫Ô∏è Teleport h·ªó tr·ª£
local function teleportTo(part)
	local hrp = getHumanoidRootPart()
	if hrp and part and part.CFrame then
		hrp.CFrame = part.CFrame + Vector3.new(0, 10, 0)
	end
end

local function teleportToLocation()
	warn("üö∂‚Äç‚ôÇÔ∏è ƒêang teleport v·ªÅ v·ªã tr√≠ map 269...")
	local hrp = getHumanoidRootPart()
	if hrp then
		hrp.CFrame = CFrame.new(-14251, 20, 1336)
	end
end

local function safeTeleportOut()
	teleportTo(workspace.__THINGS.Instances.TimeTrial.Teleports.Leave)
	task.wait(9)
	if increaseMonitorThread then pcall(task.cancel, increaseMonitorThread) increaseMonitorThread = nil end
	if lagMonitorThread then pcall(task.cancel, lagMonitorThread) lagMonitorThread = nil end
end

-- üì∫ GUI hi·ªÉn th·ªã ƒëi·ªÉm v√† l∆∞·ª£t
local screenGui = playerGui:FindFirstChild("TimeTrialGui")
if not screenGui then
	screenGui = Instance.new("ScreenGui")
	screenGui.Name = "TimeTrialGui"
	screenGui.ResetOnSpawn = false
	screenGui.Parent = playerGui
end

local function createLabel(name, position, anchor, bgColor)
	local label = Instance.new("TextLabel")
	label.Name = name
	label.AnchorPoint = anchor
	label.Position = position
	label.Size = UDim2.new(0, 0, 0, 38)
	label.BackgroundColor3 = bgColor
	label.TextColor3 = Color3.new(1, 1, 1)
	label.Font = Enum.Font.GothamBold
	label.TextSize = 32
	label.BackgroundTransparency = 0
	label.BorderSizePixel = 0
	label.TextXAlignment = Enum.TextXAlignment.Center
	label.Text = "..."
	label.Parent = screenGui
	return label
end

local function updateLabelSize(label)
	label.Size = UDim2.new(0, label.TextBounds.X + 20, 0, 38)
end

local timeTrialLabel = screenGui:FindFirstChild("TimeTrialLabel") or createLabel("TimeTrialLabel", UDim2.new(0.79, 0, 0.1, -55), Vector2.new(0, 0), Color3.fromRGB(128, 0, 128))

task.spawn(function()
	while true do

		timeTrialLabel.Text = tostring(getRunsLeft())
		updateLabelSize(timeTrialLabel)
		task.wait(10)
	end
end)

-- üîç Ch·ªù ƒë·∫øn khi ƒë·∫°t MaxZone ·ªü map 4
local function getMaxZoneFromMap4()
	local mapFolder = workspace:FindFirstChild("Map4")
	if not mapFolder then return 0 end
	local maxZone = 0
	for _, folder in ipairs(mapFolder:GetChildren()) do
		if folder:IsA("Folder") then
			local zoneNumber = tonumber(folder.Name:match("^(%d+)"))
			if zoneNumber and zoneNumber > maxZone then
				maxZone = zoneNumber
			end
		end
	end
	return maxZone
end

local function waitUntilReachMaxZone()
	local maxMapZone = getMaxZoneFromMap4()
	while true do
		local success, data = pcall(function()
			local _, zoneData = ZoneCmds.GetMaxOwnedZone()
			return zoneData
		end)
		local current = success and data and data.ZoneNumber or 0
		if current >= maxMapZone then
			warn("‚úÖ ƒê√£ ƒë·∫°t Zone t·ªëi ƒëa (" .. tostring(current) .. ")")
			break
		end
		warn("‚è≥ Ch∆∞a ƒë·∫°t Zone t·ªëi ƒëa (" .. tostring(current) .. "/" .. tostring(maxMapZone) .. "), ƒë·ª£i 60s...")
		task.wait(6000)
	end
end

-- ‚è±Ô∏è Monitor 12 ph√∫t kh√¥ng tƒÉng l∆∞·ª£t
local function startMonitor12Min()
	monitor12minThread = task.spawn(function()
		while true do
			if getRunsUsed() >= 10 then
				warn("üõë ƒê√£ ƒë·ªß 10 l∆∞·ª£t ‚Üí d·ª´ng theo d√µi 12 ph√∫t.")
				return
			end

			local startUsed = getRunsUsed()
			local startTotal = getTotalRuns()
			local t = 0
			while t < 600 do
				task.wait(10)
				t += 10
				if getRunsUsed() ~= startUsed or getTotalRuns() ~= startTotal then break end
				if getRunsUsed() >= 10 then return end
			end

			if getRunsUsed() == startUsed and getTotalRuns() == startTotal then		
				
				player:Kick("‚è∞ 10 ph√∫t kh√¥ng ƒë·ªïi l∆∞·ª£t ho·∫∑c t·ªïng Time Trial ‚Üí nghi ng·ªù treo m√°y.")
				return
			end
		end
	end)
end

-- üìå Theo d√µi ƒë·ª©ng y√™n
local function startLagMonitor()
	lagMonitorThread = task.spawn(function()
		local retryCount = 0
		local lastPosition = nil
		while true do
			local hrp = getHumanoidRootPart()
			if not hrp then task.wait(5) continue end

			lastPosition = hrp.Position
			task.wait(60)

			local currentPos = hrp.Position
			if (lastPosition - currentPos).Magnitude < 1 then
				retryCount += 1
				warn("‚ö†Ô∏è ƒê·ª©ng im " .. retryCount .. " l·∫ßn")

				if retryCount > 3 then
					player:Kick("Lag qu√° l√¢u trong Time Trial.")
					return
				else
					lagFlag = true
					safeTeleportOut()
				end
			else
				retryCount = 0
			end
			task.wait(5)
		end
	end)
end

-- üß† Theo d√µi tƒÉng ƒëi·ªÉm
local function startIncreaseMonitor(startPoints, startRuns)
	increaseMonitorThread = task.spawn(function()
		warn("‚è≥ Theo d√µi tƒÉng ƒêi·ªÉm/TotalRuns")
		while true do
			if lagFlag then return end
			if getTimeTrialPoints() > startPoints or getTotalRuns() > startRuns then
				warn("‚úÖ ƒêi·ªÉm ho·∫∑c TotalRuns tƒÉng ‚Üí Tho√°t Time Trial")
				endFlag = true
				safeTeleportOut()
				return
			end
			task.wait(1)
		end
	end)
end

-- üîÅ Teleport farm breakables
local function teleportFarmLoop(startPoints, startRuns)
	while true do
		if lagFlag or endFlag or _G.STOP_TIME_TRIAL then
			warn("‚ö†Ô∏è D·ª´ng teleportFarmLoop")
			return
		end

		-- üîç Ki·ªÉm tra nh√¢n v·∫≠t ƒë√£ h·ªìi sinh v√† c√≥ HRP ch∆∞a
		local hrp = getHumanoidRootPart()
		if not hrp then
			warn("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y HumanoidRootPart ‚Üí ƒë·ª£i h·ªìi sinh...")
			task.wait(3)
			continue
		end

		local names = {}
		for _, c in ipairs(workspace.__THINGS.Breakables:GetChildren()) do
			if c:IsA("Model") and tonumber(c.Name) then
				table.insert(names, c.Name)
			end
		end

		if #names > 0 then
			for _, n in ipairs(names) do
				if lagFlag or endFlag or _G.STOP_TIME_TRIAL then return end
				local b = workspace.__THINGS.Breakables:FindFirstChild(n)
				if b then
					local p = b:FindFirstChildWhichIsA("BasePart")
					if p then
						teleportTo(p)
						while workspace.__THINGS.Breakables:FindFirstChild(n) do
							if lagFlag or endFlag or _G.STOP_TIME_TRIAL then return end
							task.wait(0.1)
						end
					end
				end
			end
		else
			warn("‚è≥ Kh√¥ng c√≥ r∆∞∆°ng, ch·ªù 20s...")
			local found = false
			for i = 1, 200 do
				if lagFlag or endFlag or _G.STOP_TIME_TRIAL then return end
				task.wait(0.1)
				for _, c in ipairs(workspace.__THINGS.Breakables:GetChildren()) do
					if c:IsA("Model") and tonumber(c.Name) then
						found = true
						break
					end
				end
				if found then break end
			end
			if not found then
				warn("‚ùå H·∫øt r∆∞∆°ng ‚Üí k·∫øt th√∫c l∆∞·ª£t")
				endFlag = true
				safeTeleportOut()
				return
			end
		end

		task.wait(0.1)
	end
end

-- üßπ Cleanup to√†n b·ªô threads
local function cleanupAllThreads()
	warn("üßπ Cleanup to√†n b·ªô thread & tr·∫°ng th√°i")
	if lagMonitorThread then pcall(task.cancel, lagMonitorThread) lagMonitorThread = nil end
	if increaseMonitorThread then pcall(task.cancel, increaseMonitorThread) increaseMonitorThread = nil end
	if monitor12minThread then pcall(task.cancel, monitor12minThread) monitor12minThread = nil end
	lagFlag = false
	endFlag = false
	_G.STOP_TIME_TRIAL = false
	_G.VAR_TIME_TRIAL = nil
end

-- üéÅ ƒê·ªïi qu√†
local function claimReward()

Thu_7_openall = false
if Thu_7_openall == true then
	diem_toi_thieu_thoat = 999
else
	diem_toi_thieu_thoat = 4999
end

if getTimeTrialPoints() < diem_toi_thieu_thoat then	
return 
end

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- H√†m teleport ƒë·∫øn v·ªã tr√≠ nh·∫≠n th∆∞·ªüng
local function teleportToRewardLocation()
    warn("üö∂‚Äç‚ôÇÔ∏è ƒêang teleport ƒë·∫øn v·ªã tr√≠ ƒë·ªïi qu√†...")
    player.Character.HumanoidRootPart.CFrame = CFrame.new(-14186, 20, 2206)
end

-- H√†m m·ªü chest v·ªõi s·ªë ƒëi·ªÉm nh·∫•t ƒë·ªãnh
local function openChest(pointsRequired, chestId)
    if getTimeTrialPoints() >= pointsRequired then
        teleportToRewardLocation()
        wait(0.5)
        local FantasyKey_Unlock = ReplicatedStorage.Network.TimeTrials_OpenChest
        FantasyKey_Unlock:InvokeServer(chestId)
        wait(1)
  
  
    end
end

while true do

	openChest(5000, 3)  -- M·ªü chest y√™u c·∫ßu 5000 ƒëi·ªÉm
	openChest(5000, 3)  -- M·ªü chest y√™u c·∫ßu 5000 ƒëi·ªÉm
	openChest(5000, 3)  -- M·ªü chest y√™u c·∫ßu 5000 ƒëi·ªÉm
	if Thu_7_openall == true then
		openChest(3000, 2)  -- M·ªü chest y√™u c·∫ßu 3000 ƒëi·ªÉm	
		openChest(1000, 1)  -- M·ªü chest y√™u c·∫ßu 1000 ƒëi·ªÉm
	end
	if getTimeTrialPoints() < diem_toi_thieu_thoat then
		break
	end
wait(2)
end


end


-- ‚úÖ V√íNG L·∫∂P CH√çNH
task.spawn(function()

	
		if game.PlaceId ~= 140403681187145 then return end
		
		
	--waitUntilReachMaxZone()
	startMonitor12Min()		
		
		
	while true do
		-- s√°ch trial time
		autoEquipEnchantBooks({"Explosive","Chest Breaker","Criticals","Strong Pets","Fruity","Happy Pets","Super Lightning","Tap Power","Large Taps"})
		while getRunsUsed() < 10 do
			
			local used = getRunsUsed()
			lagFlag = false
			endFlag = false

			if used > 0 then
				warn("‚è∏Ô∏è Ngh·ªâ 30s tr∆∞·ªõc l∆∞·ª£t ti·∫øp theo...")
				task.wait(30)
			end

			local startPoints = getTimeTrialPoints()
			local startRuns = getTotalRuns()

			warn("üîÅ B·∫Øt ƒë·∫ßu l∆∞·ª£t: " .. tostring(used))
			teleportTo(workspace.__THINGS.Instances.TimeTrial.Teleports.Enter)
			task.wait(5)
			_OFF_ON_pet()
			local retry = 0
			while not workspace.__THINGS.__INSTANCE_CONTAINER.Active:FindFirstChild("TimeTrial") and retry < 3 do
				retry += 1
				warn("‚ùå V√†o th·∫•t b·∫°i, th·ª≠ l·∫°i...")
				teleportTo(workspace.__THINGS.Instances.TimeTrial.Teleports.Enter)
				task.wait(5)
			end

			if not workspace.__THINGS.__INSTANCE_CONTAINER.Active:FindFirstChild("TimeTrial") then
				warn("‚õî Kh√¥ng th·ªÉ v√†o Time Trial.")
				safeTeleportOut()
				task.wait(5)
				teleportTo(workspace.__THINGS.Instances.TimeTrial.Teleports.Enter)
				task.wait(5)
			end

			startLagMonitor()
			startIncreaseMonitor(startPoints, startRuns)
			teleportFarmLoop(startPoints, startRuns)
			task.wait(5)

			if lagMonitorThread then pcall(task.cancel, lagMonitorThread) lagMonitorThread = nil end
			if increaseMonitorThread then pcall(task.cancel, increaseMonitorThread) increaseMonitorThread = nil end
		end
		warn("üéâ Ho√†n t·∫•t 10/10 l∆∞·ª£t Time Trial.")
		claimReward()
		task.wait(30)
		cleanupAllThreads()
		autoEquipEnchantBooks({"Lucky Eggs","Lucky Eggs","Huge Hunter","Shiny Hunter","Diamonds","Treasure Hunter","Huge Hunter","Treasure Hunter","Lucky Eggs"})
		_G.VAR_STOP_BLOCK_PARTY = false
		_G.VAR_START_BLOCK_PARTY = true
		-- Event
		
		
		
		--local player = game.Players.LocalPlayer			
		---- üß≠ Teleport v√†o Block Party & ƒë·∫øn v·ªã tr√≠ c·ª• th·ªÉ
		--function teleportTo(cf)
		--	local character = player.Character or player.CharacterAdded:Wait()
		--	local hrp = character:FindFirstChild("HumanoidRootPart")
		--	if hrp then
		--		hrp.CFrame = cf
		--	end
		--end
		--local Enter = workspace.__THINGS.Instances.BlockParty.Teleports.Enter	
		--teleportTo(Enter.CFrame + Vector3.new(0, 5, 0))
		--task.wait(9)
		
		warn("‚è≥ Theo d√µi reset DailyRuns...")
		while getRunsUsed() >= 10 do 				
			task.wait(600) 
		end
		_G.VAR_STOP_BLOCK_PARTY = true
		_G.VAR_START_BLOCK_PARTY = false

		warn("üîÅ DailyRuns reset ‚Üí ti·∫øp t·ª•c farm.")
		if monitor12minThread then pcall(task.cancel, monitor12minThread) monitor12minThread = nil end
		startMonitor12Min()
	end
	
end)



end)

-- ticket summer
task.spawn(function()


while true do

time_random= math.random(3600,7200)
warn(time_random)
wait(time_random)

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Raffle_Submit = ReplicatedStorage.Network.Raffle_Submit 

Raffle_Submit:InvokeServer(
    "TileRaffle",
    5,
    false
)


end

end)

-- event block patry
task.spawn(function()

wait(150)


_G.VAR_BLOCK_PARTY = true
local isRunning = false

-- ‚öôÔ∏è D·ªãch v·ª• & Folder
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local player = game.Players.LocalPlayer
local TilesFolder = Workspace:WaitForChild("__THINGS"):WaitForChild("Tiles")
local NLibrary = ReplicatedStorage.Library
local EggCmds = require(NLibrary.Client.EggCmds)
local Save = require(ReplicatedStorage.Library.Client.Save)
local Network = ReplicatedStorage:WaitForChild("Network")
local CustomEggsFolder = Workspace:WaitForChild("__THINGS"):WaitForChild("CustomEggs")

-- üî¢ ƒê·∫øm t·ªïng s·ªë tile
local function getTotalTileCount()
	return #TilesFolder:GetChildren()
end

-- üß† D·ª´ng to√†n b·ªô khi b·ªã stop
local function waitUntilAllowed()
	while _G.VAR_STOP_BLOCK_PARTY and not _G.VAR_START_BLOCK_PARTY do
		warn("‚è∏ Script ƒëang b·ªã t·∫°m d·ª´ng b·ªüi _G.VAR_STOP_BLOCK_PARTY")
		task.wait(10)
	end
	if not _G.VAR_START_BLOCK_PARTY then
		isRunning = false
	end
end

function teleportTo(cf)
	local character = player.Character or player.CharacterAdded:Wait()
	local hrp = character:FindFirstChild("HumanoidRootPart")
	if hrp then
		hrp.CFrame = cf
	end
end

local function teleportToBlockParty()
	local Enter = workspace.__THINGS.Instances.BlockParty.Teleports.Enter

	-- üß≠ Teleport v√†o Block Party & ƒë·∫øn v·ªã tr√≠ c·ª• th·ªÉ
	teleportTo(Enter.CFrame + Vector3.new(0, 5, 0))
	task.wait(9)
end

---------------- üß© LU·ªíNG 1: Mua tiles quanh plot ----------------
local function startAutoPurchase()
	print("Auto Purchase")
	local radiusMax = 6
	local delayPerTile = 0.5
	local delayPerCycle = 0.5

	local PlotsInvoke = ReplicatedStorage:WaitForChild("Network"):WaitForChild("Plots_Invoke")

	-- üí† T·∫°o danh s√°ch offsets quanh plot
	local offsets = {}
	for dx = -radiusMax, radiusMax do
		for dy = -radiusMax, radiusMax do
			if not (dx == 0 and dy == 0) then
				table.insert(offsets, {dx, dy})
			end
		end
	end

	-- üìå H√†m l·∫•y plotIndex ƒë·ªông
	local function getCurrentPlotIndex()
		local index = 1
		pcall(function()
			local plots = Workspace.__THINGS:FindFirstChild("Plots")
			if plots then
				for _, v in ipairs(plots:GetChildren()) do
					if tonumber(v.Name) then
						index = tonumber(v.Name)
						break
					end
				end
			end
		end)
		return index
	end

	while true do

		if _G.VAR_STOP_BLOCK_PARTY and not _G.VAR_START_BLOCK_PARTY then
			warn("Finish AutoPurchase")
			break
		end
		
		local saveData = Save.Get()
		local tileRebirth = saveData.TileRebirth or 0
		local totalTiles = getTotalTileCount()
		local hugeChance = _G.CURRENT_HUGE_CHANCE or 0

		-- üõë D·ª´ng h·∫≥n n·∫øu ƒë·ªß 3 ƒëi·ªÅu ki·ªán
		if tileRebirth >= 15 and totalTiles >= 169 and hugeChance >= 5 then
			warn("‚úÖ ƒê√£ ƒë·∫°t ƒë·ªß ƒëi·ªÅu ki·ªán (Tiles ‚â•169, Rebirth ‚â•15, HugeChance ‚â•25x) ‚Üí D·ª´ng Auto Purchase.")
			break
		end

		if totalTiles >= 169 then
			warn("‚è≥ Tiles ‚â•169 ‚Üí ch·ªù 30s tr∆∞·ªõc khi ki·ªÉm tra l·∫°i.")
			task.wait(30)
		else
			for _, offset in ipairs(offsets) do
				local plotIndex = getCurrentPlotIndex()
				local args = {plotIndex, "PurchaseTile", offset[1], offset[2]}
				pcall(function()
					PlotsInvoke:InvokeServer(unpack(args))
				end)
				task.wait(delayPerTile)
				if _G.VAR_STOP_BLOCK_PARTY and not _G.VAR_START_BLOCK_PARTY then
					warn("Finish AutoPurchase")
					break
				end
			end
			task.wait(delayPerCycle)
		end
	end
end
---------------- üß© LU·ªíNG 2: Claim + Open + Unlock + Plant + Diamond ----------------
local function startTileHandler()
	local TilesInvoke = ReplicatedStorage:WaitForChild("Network"):WaitForChild("Tiles_Invoke")
	local TilesFire = ReplicatedStorage:WaitForChild("Network"):WaitForChild("Tiles_Fire")
	local delayPerTile = 0.5
	local delayPerCycle = 0.5

	while true do
		waitUntilAllowed()
		for _, tile in ipairs(TilesFolder:GetChildren()) do
			local tileId = tile.Name

			-- ‚úÖ Claim + Open (Tiles_Invoke)
			pcall(function() TilesInvoke:InvokeServer(tileId, "Claim") end)
			pcall(function() TilesInvoke:InvokeServer(tileId, "Open") end)

			-- ‚úÖ Claim + Unlock (Tiles_Fire)
			pcall(function() TilesFire:FireServer(tileId, "Claimed") end)
			pcall(function() TilesFire:FireServer(tileId, "Unlock") end)

			-- ‚úÖ Claim Plant[i] (1 -> 6)
			if tile:IsA("Model") or tile:IsA("Folder") then
				if tile:FindFirstChild("Plant1") then
					for i = 1, 6 do
						pcall(function()
							TilesInvoke:InvokeServer(tileId, "Claim", i)
						end)
						task.wait(0.05)
					end
				end

				-- ‚úÖ Claim Diamond
				if tile:FindFirstChild("Diamond") then
					pcall(function()
						TilesInvoke:InvokeServer(tileId, "Tile_ClaimDiamonds")
					end)
					task.wait(0.1)
				end
			end

			task.wait(delayPerTile)
		end

		task.wait(delayPerCycle)
	end
end

---------------- üß© LU·ªíNG 3: Hatch HUGE CHANCE ----------------
local currentChance = 0
local tileThreshold = 120

local function extractHugeLuckValue(text)
	local value = text:match("(%d+)x%s+Huge%s+Luck!?")
	return tonumber(value or "0")
end

local function findEggNearTile(tile)
	local closestEgg, minDist = nil, math.huge
	for _, eggModel in pairs(CustomEggsFolder:GetChildren()) do
		local egg = eggModel:FindFirstChild("Egg")
		if egg and egg:FindFirstChild("slashes") and eggModel:IsA("Model") then
			local part = eggModel:FindFirstChild("Part")
			if part and tile.PrimaryPart then
				local dist = (part.Position - tile.PrimaryPart.Position).Magnitude
				if dist < minDist then
					closestEgg, minDist = eggModel, dist
				end
			end
		end
	end
	return closestEgg
end

local function findBestHugeTile()
	local bestTile, bestValue = nil, -1
	for _, tile in pairs(TilesFolder:GetChildren()) do
		local label = tile:FindFirstChild("Sign")
			and tile.Sign:FindFirstChild("SurfaceGui")
			and tile.Sign.SurfaceGui:FindFirstChild("Frame")
			and tile.Sign.SurfaceGui.Frame:FindFirstChild("Frame")
			and tile.Sign.SurfaceGui.Frame.Frame:FindFirstChild("TextLabel")
		if label and label:IsA("TextLabel") then
			local value = extractHugeLuckValue(label.Text)
			if value > bestValue then
				local egg = findEggNearTile(tile)
				if egg then
					bestTile, bestValue = tile, value
				end
			end
		end
	end
	_G.CURRENT_HUGE_CHANCE = bestValue
	return bestTile, bestValue
end

local function teleportToTile(tile)
	if tile and tile:IsA("Model") and tile.PrimaryPart then
		teleportTo(tile.PrimaryPart.CFrame + Vector3.new(0, 5, 0))
		print("üìç Teleport ƒë·∫øn tile:", tile.Name)
	end
end

local function handleRejoin()
	local Workspace = game:GetService("Workspace")
	local Leave = workspace.__THINGS.Instances.LuckyBlocks.Teleports.Leave
	teleportTo(Leave.CFrame + Vector3.new(0, 5, 0))
	task.wait(9)
	teleportToBlockParty()

end

local function isNearEgg(egg)
	local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
	if not (hrp and egg) then return false end
	local part = egg:FindFirstChild("Part")
	if not part then return false end
	return (hrp.Position - part.Position).Magnitude < 15
end

local function startAutoHatchHuge()
	task.wait(20)

	-- T·∫Øt animation m·ªü tr·ª©ng
	local successEggs, Eggs = pcall(function()
		return player:WaitForChild("PlayerScripts"):WaitForChild("Scripts"):WaitForChild("Game"):WaitForChild("Egg Opening Frontend")
	end)
	if successEggs and Eggs then
		pcall(function()
			getsenv(Eggs).PlayEggAnimation = function() return end
		end)
	end

	local bestTile, bestEgg = nil, nil
	local MaxEggHatch = EggCmds.GetMaxHatch()
	
	local function safeHatchLoop()
		while true do
			waitUntilAllowed()

			while getTotalTileCount() < tileThreshold do
				warn("‚è≥ Tiles hi·ªán t·∫°i d∆∞·ªõi " .. tileThreshold .. " ‚Üí ƒëang ch·ªù...")
				task.wait(3)
			end

			if not bestEgg or not bestEgg:IsDescendantOf(workspace) then
				warn("‚ùå Egg hi·ªán t·∫°i ƒë√£ m·∫•t, ƒëang t√¨m l·∫°i...")
				task.wait(2)
				bestEgg = findEggNearTile(bestTile)
				if bestEgg then
					print("‚úÖ ƒê√£ t√¨m l·∫°i ƒë∆∞·ª£c egg:", bestEgg.Name)
					teleportTo(bestEgg.Part.CFrame + Vector3.new(0, 5, 0))
					task.wait(1)
				else
					print("‚ùå Kh√¥ng t√¨m th·∫•y egg ‚Üí reset map")
					handleRejoin()
					break
				end
			end

			if not isNearEgg(bestEgg) then
				print("üö∂‚Äç‚ôÇÔ∏è Kh√¥ng ·ªü g·∫ßn egg, teleport l·∫°i...")
				teleportTo(bestEgg.Part.CFrame + Vector3.new(0, 5, 0))
				task.wait(1)
			end

			
			local args = {bestEgg.Name, MaxEggHatch}
			local success, err = pcall(function()
				Network.CustomEggs_Hatch:InvokeServer(unpack(args))
			end)
			if not success then
				warn("‚ùå Hatch l·ªói:", err)
			end

			task.wait(0.5)
			if _G.CURRENT_HUGE_CHANCE < 25 and getTotalTileCount() == 169 then
				warn("rebirth t√¨m egg X5")	
				wait(10)
				local PlotsInvoke = ReplicatedStorage:WaitForChild("Network"):WaitForChild("Plots_Invoke")
				local args = {1, "Rebirth"}
				pcall(function()
					PlotsInvoke:InvokeServer(unpack(args))
					print("üîÅ ƒê√£ g·ª≠i y√™u c·∫ßu Rebirth | TileRebirth hi·ªán t·∫°i:", tileRebirth)
				end)							
				wait(4)			
				if getTotalTileCount() == 169 then					
					game:Shutdown() -- ‚ö†Ô∏è L·ªánh shutdown client
					Players.LocalPlayer:Kick("kick")
				end
							task.spawn(function()
								wait(2)
								startAutoPurchase()
							end)
				break
			end
		end
	end

	while true do
		waitUntilAllowed()
		if getTotalTileCount() >= tileThreshold then
			warn("ƒê·ªß getTotalTileCount")
			local initialTile, initialChance = findBestHugeTile()
			if initialTile and initialChance > 0 then
				currentChance = initialChance
				
				bestTile = initialTile
				bestEgg = findEggNearTile(initialTile)
				teleportToTile(bestTile)
				task.wait(1)
				print("ü•ö B·∫Øt ƒë·∫ßu n·ªü ·ªü tile:", bestTile.Name, "|", currentChance .. "x")

				task.spawn(function()
					while true do
						task.wait(600)
						waitUntilAllowed()
						local newTile, newChance = findBestHugeTile()
						if newTile and newTile.PrimaryPart and newChance > currentChance then
							currentChance = newChance
							print("üîÅ Tile m·ªõi t·ªët h∆°n:", newTile.Name, "|", newChance .. "x")

							bestTile = newTile
							bestEgg = findEggNearTile(newTile)
							teleportToTile(newTile)
							task.wait(1)

							if bestEgg then
								print("‚úÖ Egg m·ªõi:", bestEgg.Name)
							else
								warn("‚ùå Kh√¥ng t√¨m th·∫•y egg m·ªõi!")
							end
						else
							print("‚è∏ V·∫´n gi·ªØ tile:", bestTile.Name, "|", currentChance .. "x")
						end
					end
				end)
				
				safeHatchLoop()
			else
				print("‚ùå Kh√¥ng c√≥ tile n√†o c√≥ Huge Chance + egg.slashes ‚Üí th·ª≠ teleport th·ªß c√¥ng tr∆∞·ªõc khi reset")
				teleportTo(CFrame.new(16460, 2275, -21473))
				task.wait(3)

				local retryTile, retryChance = findBestHugeTile()
				if retryTile and retryChance > 0 then
					print("‚úÖ ƒê√£ t√¨m th·∫•y tile sau khi teleport th·ªß c√¥ng:", retryTile.Name, "|", retryChance .. "x")
					currentChance = retryChance
					bestTile = retryTile
					bestEgg = findEggNearTile(retryTile)
					teleportToTile(retryTile)
					task.wait(1)					
					
					safeHatchLoop()
				else
					print("‚ùå V·∫´n kh√¥ng t√¨m th·∫•y tile ‚Üí reset map")
					handleRejoin()
				end
			end
		end
		task.wait(5)
	end
end

---------------- üß© LU·ªíNG 4: Auto SummerGiftBag2025 ----------------
local function startAutoGiftBag()
    local function getCurrencyAmount(itemId)
        local Inventory = Save.Get().Inventory
        for _, v in pairs(Inventory.Misc) do 
            if v.id == itemId then
                return tonumber(v._am) or 0
            end
        end
        return 0
    end

    while true do
        waitUntilAllowed()

        if getTotalTileCount() >= 50 then
            local flowerCount = getCurrencyAmount("Tropical Flower")
            if flowerCount >= 10 then
                local args = {10}
                pcall(function()
                    Network.SummerGiftBag2025Machine_Activate:InvokeServer(unpack(args))
                    print("üéÅ ƒê√£ ƒë·ªïi 10 Tropical Flower th√†nh Gift Bag")
                end)
            end
        end

        task.wait(30)
    end
end

---------------- üß© LU·ªíNG 5: Auto Rebirth ----------------
local function startAutoRebirth()
	local PlotsInvoke = ReplicatedStorage:WaitForChild("Network"):WaitForChild("Plots_Invoke")
	local threshold = 169
	local maxTileRebirth = 15

	while true do
		waitUntilAllowed()
		local saveData = Save.Get()
		local tileRebirth = saveData.TileRebirth or 0

		if tileRebirth >= maxTileRebirth then
			warn("üõë ƒê√£ ƒë·∫°t TileRebirth =", tileRebirth, "- D·ª´ng Auto Rebirth.")
			break
		end

		if getTotalTileCount() == threshold then
			local args = {1, "Rebirth"}
			pcall(function()
				PlotsInvoke:InvokeServer(unpack(args))
				print("üîÅ ƒê√£ g·ª≠i y√™u c·∫ßu Rebirth | TileRebirth hi·ªán t·∫°i:", tileRebirth)
			end)
		end

		task.wait(2)
	end
end

---------------- üß© LU·ªíNG 6: GUI Coins / Tiles / Chance ----------------
local function startGuiUpdater()
	local player = Players.LocalPlayer
	local playerGui = player:WaitForChild("PlayerGui")

	local oldGui = playerGui:FindFirstChild("BlockPartyGui")
	if oldGui then
		oldGui:Destroy()
	end

	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "BlockPartyGui"
	screenGui.ResetOnSpawn = false
	screenGui.Parent = playerGui

	local function getCurrencyAmount(currencyId)
		local Inventory = Save.Get().Inventory
		for _, v in pairs(Inventory.Currency) do 
			if v.id == currencyId then
				return v._am
			end
		end
		return 0
	end

	local function createLabel(name, position, anchor, bgColor)
		local label = Instance.new("TextLabel")
		label.Name = name
		label.AnchorPoint = anchor
		label.Position = position
		label.Size = UDim2.new(0, 0, 0, 38)
		label.BackgroundColor3 = bgColor
		label.TextColor3 = Color3.new(1, 1, 1)
		label.Font = Enum.Font.GothamBold
		label.TextSize = 32
		label.BackgroundTransparency = 0
		label.BorderSizePixel = 0
		label.TextXAlignment = Enum.TextXAlignment.Center
		label.Text = "..."
		label.Parent = screenGui
		return label
	end

	local function updateLabelSize(label)
		label.Size = UDim2.new(0, label.TextBounds.X + 20, 0, 38)
	end

	local tilesLabel  = createLabel("TilesLabel",  UDim2.new(0, -10, 0.2, -10), Vector2.new(0, 0), Color3.fromRGB(0, 128, 0))
	local coinsLabel  = createLabel("CoinsLabel",  UDim2.new(0.5, -15, 0.2, -10), Vector2.new(0.5, 0), Color3.fromRGB(255, 165, 0))
	local chanceLabel = createLabel("ChanceLabel", UDim2.new(1, -30, 0.2, -10), Vector2.new(1, 0), Color3.fromRGB(0, 102, 204))

	while true do
		waitUntilAllowed()
		tilesLabel.Text  = "T: " .. tostring(getTotalTileCount())
		updateLabelSize(tilesLabel)

		coinsLabel.Text  = "C: " .. tostring(getCurrencyAmount("BlockPartyCoins"))
		updateLabelSize(coinsLabel)

		chanceLabel.Text = tostring(currentChance) .. "x HUGE"
		updateLabelSize(chanceLabel)

		task.wait(1)
	end
end

local function check_Egghatch()

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Client = ReplicatedStorage:WaitForChild("Library"):WaitForChild("Client")
local SaveData = require(Client.Save).Get

local lastEggsHatched = nil

while true do
	task.wait(60)
	local data = SaveData()
	if data and data.EggsHatched then
		local current = data.EggsHatched

		if current == lastEggsHatched and getTotalTileCount() == 169 then
			Players.LocalPlayer:Kick("EggsHatched = 0")
			break
		else
			lastEggsHatched = current
			warn(lastEggsHatched)
		end
	end

	task.wait(60)
end

end

---------------- üöÄ K√≠ch ho·∫°t t·∫•t c·∫£ lu·ªìng song song ----------------
local function startAllBlockPartyTasks()
	--teleportToBlockParty()
	if isRunning then return end
	isRunning = true
	print("üöÄ ƒê√£ k√≠ch ho·∫°t startAllBlockPartyTasks")
	
	---- üß© LU·ªíNG 1: Auto Purchase
	--task.spawn(function()
	--	local Save = require(ReplicatedStorage.Library.Client.Save)
	--	while true do
	--		local saveData = Save.Get()
	--		local tileRebirth = saveData.TileRebirth or 0
	--		local totalTiles = getTotalTileCount()
	--
	--		if tileRebirth < 15 or totalTiles < 169 then
	--			print("‚úÖ ƒê√£ kh·ªüi ƒë·ªông LU·ªíNG 1: Auto Purchase")
	--			startAutoPurchase()
	--			break
	--		end
	--		task.wait(5)
	--	end
	--end)
	
	-- üß© LU·ªíNG 2: Tile Handler
	task.spawn(function()
		print("‚úÖ ƒê√£ kh·ªüi ƒë·ªông LU·ªíNG 2: Tile Handler (Claim/Open/Unlock/Plant/Diamond)")
		startTileHandler()
	end)

	---- üß© LU·ªíNG 5: Hatch HUGE
	--task.spawn(function()
	--	while true do
	--		while getTotalTileCount() < 120 do
	--			task.wait(2)
	--		end
	--		print("‚úÖ ƒê√£ kh·ªüi ƒë·ªông LU·ªíNG 3: Hatch HUGE CHANCE")
	--		startAutoHatchHuge()
	--	end
	--end)

	-- üß© LU·ªíNG 6: Auto Gift Bag
	--task.spawn(function()
	--	while true do
	--		while getTotalTileCount() < 160 do
	--			task.wait(2)
	--		end
	--		print("‚úÖ ƒê√£ kh·ªüi ƒë·ªông LU·ªíNG 4: Auto SummerGiftBag2025")
	--		startAutoGiftBag()
	--	end
	--end)

	-- üß© LU·ªíNG 7: Auto Rebirth
	--task.spawn(function()
	--	local Save = require(ReplicatedStorage.Library.Client.Save)
	--	while true do
	--		local saveData = Save.Get()
	--		local tileRebirth = saveData.TileRebirth or 0
	--		if tileRebirth < 15 then
	--			print("‚úÖ ƒê√£ kh·ªüi ƒë·ªông LU·ªíNG 5: Auto Rebirth")
	--			startAutoRebirth()
	--			break
	--		end
	--		task.wait(5)
	--	end
	--end)



	-- üß© LU·ªíNG 8: GUI Updater
	task.spawn(function()
		print("‚úÖ ƒê√£ kh·ªüi ƒë·ªông LU·ªíNG 6: GUI Updater")
		--startGuiUpdater()
	end)
	-- üß© LU·ªíNG 9: check join event
	
	task.spawn(function()
		print("‚úÖ ƒê√£ kh·ªüi ƒë·ªông check join event")
		wait(99)
		while true do
			waitUntilAllowed()
			if getTotalTileCount() == 0 then
				print("join event")
				handleRejoin()
			end
			wait(33)
		end		
	end)

	task.spawn(function()
		print("‚úÖ ƒê√£ kh·ªüi ƒë·ªông check_Egghatch")
		wait(99)
		while true do
			waitUntilAllowed()
			check_Egghatch()
			wait(33)
		end		
	end)
	
end

task.spawn(function()
	while true do

		if _G.VAR_START_BLOCK_PARTY then
			startAllBlockPartyTasks()
			break
		end

		task.wait(2)
	end
end)


end)

-- xem sl 7 s√°ch th∆∞·ªùng d√πng
task.spawn(function()
task.wait(60)
local booksToCheck = {
    "Diamonds","Lucky Eggs","Treasure Hunter"
}

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local SaveData = require(ReplicatedStorage.Library.Client.Save).Get()

-- ƒê·∫øm s·ªë s√°ch TN = 10 theo t√™n
local function findBookAmount(bookName)
    local results = 0
    local subTable = SaveData.Inventory.Enchant
    if type(subTable) ~= "table" then return 0 end

    for _, v in pairs(subTable) do
        if typeof(v) == "table" and v.id == bookName and v.tn == 10 then
            results += tonumber(v._am) or 1
        end
    end

    return results
end

-- T·∫°o UI 1 h√†ng ngang v·ªõi k√≠ch th∆∞·ªõc vu√¥ng
local function createCounterUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "BookCounterUI"
    screenGui.ResetOnSpawn = false
    screenGui.IgnoreGuiInset = true
    screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

    local container = Instance.new("Frame", screenGui)
    container.Name = "Container"
    container.AnchorPoint = Vector2.new(0.5, 0)
    container.Position = UDim2.new(0.5, 0, 0.2, 0) -- Tr√™n ƒë·∫ßu, d∆∞·ªõi t√™n ng∆∞·ªùi ch∆°i
    container.Size = UDim2.new(0, 75 * #booksToCheck, 0, 75)
    container.BackgroundTransparency = 1

    for i = 1, #booksToCheck do
        local box = Instance.new("TextLabel", container)
        box.Name = "Box_" .. i
        box.Size = UDim2.new(0, 70, 0, 70)
        box.Position = UDim2.new(0, (i - 1) * 75, 0, 0)
        box.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        box.TextColor3 = Color3.new(1, 1, 1)
        box.TextStrokeTransparency = 0.1
        box.BorderSizePixel = 0
        box.TextScaled = true
        box.Font = Enum.Font.GothamBlack
        box.Text = "?"
        box.BackgroundTransparency = 0
        box.TextWrapped = true
        box.ClipsDescendants = true
    end
end

-- C·∫≠p nh·∫≠t s·ªë m·ªói 5s
local function updateCounterUI()
    local container = LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("BookCounterUI"):WaitForChild("Container")
    for i, bookName in ipairs(booksToCheck) do
        local count = findBookAmount(bookName)
        local label = container:FindFirstChild("Box_" .. i)
        if label then
            label.Text = tostring(count)
        end
    end
end

-- Kh·ªüi ƒë·ªông UI v√† c·∫≠p nh·∫≠t
createCounterUI()
task.spawn(function()
    while true do
        updateCounterUI()
        task.wait(5)
    end
end)


end)
---------------------------------------------------------------------------------------------------------------------

-- Gh√©p s√°ch + thu·ªëc n·∫øu lv < 99 
task.spawn(function()
	task.wait(150)
local Save = require(game:GetService("ReplicatedStorage").Library.Client.Save)
local level = Save.Get().Mastery and Save.Get().Mastery.Potions

if level and level < 13034430 then

    -- H√†m n√¢ng c·∫•p thu·ªëc
    local function _update_sach_theo_level(name_sach, level_sach)
        local saveModule = require(game.ReplicatedStorage.Library.Client.Save)
        local inventory = saveModule.Get() and saveModule.Get().Inventory and saveModule.Get().Inventory.Potion
        if not inventory then return end

        local count = 0
        local uid_sach = nil

        for itemUID, itemData in pairs(inventory) do
            if itemData.id == name_sach and itemData.tn == level_sach then
                count += (itemData._am or 1)
                uid_sach = tostring(itemUID)
            end
        end

        local totalUpgradeAmount = count // 3
        if uid_sach and totalUpgradeAmount > 0 then
            game:GetService("ReplicatedStorage").Network.UpgradePotionsMachine_Activate:InvokeServer(uid_sach, totalUpgradeAmount)
            --warn("Upgrade: " .. name_sach .. " UID : " .. uid_sach .. " x" .. totalUpgradeAmount .. "\n")
        end
    end

    -- Danh s√°ch s√°ch c·∫ßn n√¢ng c·∫•p
    local list = {
        "Treasure Hunter", "Walkspeed", "Strong Pets", 
        "Lucky Eggs", "Diamonds", "Coins"
    }

    for _, name in ipairs(list) do
        _update_sach_theo_level(name, 1)
		task.wait(2)
        _update_sach_theo_level(name, 2)
		task.wait(2)
    end
	
end


-----------------------
local Save = require(game:GetService("ReplicatedStorage").Library.Client.Save)
local level = Save.Get().Mastery and Save.Get().Mastery.Enchants

if level and level < 13034430 then

    -- H√†m n√¢ng c·∫•p s√°ch
    local function _update_sach_theo_level(name_sach, level_sach)
        local saveModule = require(game.ReplicatedStorage.Library.Client.Save)
        local inventory = saveModule.Get() and saveModule.Get().Inventory and saveModule.Get().Inventory.Enchant
        if not inventory then return end

        local count = 0
        local uid_sach = nil

        for itemUID, itemData in pairs(inventory) do
            if itemData.id == name_sach and itemData.tn == level_sach then
                count += (itemData._am or 1)
                uid_sach = tostring(itemUID)
            end
        end

        local totalUpgradeAmount = count // 5
        if uid_sach and totalUpgradeAmount > 0 then
            game:GetService("ReplicatedStorage").Network.UpgradeEnchantsMachine_Activate:InvokeServer(uid_sach, totalUpgradeAmount)
            --warn("Upgrade: " .. name_sach .. " lv" .. level_sach .. " x" .. totalUpgradeAmount .. "\n")
        end
    end

    -- Danh s√°ch s√°ch c·∫ßn n√¢ng c·∫•p
    local list = {
        "Treasure Hunter", "Tap Power", "Strong Pets", "Walkspeed",
        "Magnet", "Lucky Eggs", "Diamonds", "Criticals", "Coins"
    }

    for _, name in ipairs(list) do
        _update_sach_theo_level(name, 1)
		task.wait(2)
        _update_sach_theo_level(name, 2)
		task.wait(2)
    end
	
end

end)


---------------------------------------------------------------------------------------------------------------------
-- up pet gold + rainbow : Quartz Fox  Wise Cat
task.spawn(function() 
wait(20)

local NamePet_ep = {
    "Quartz Fox",
	"Wise Cat",
}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SaveData = require(ReplicatedStorage.Library.Client.Save).Get()
local Manager = {}

function Manager:GetPets(name_pet, PT_yeucau)
    local SaveData = require(ReplicatedStorage.Library.Client.Save).Get()
    local Huges = {}
    for uid, v in pairs(SaveData.Inventory.Pet) do
        if string.find(v.id, name_pet) then
            if (PT_yeucau == nil and v.pt == nil) or (PT_yeucau ~= nil and v.pt == PT_yeucau) then
                table.insert(Huges, {
                    UID   = uid,
                    SH    = v.sh,
                    PT    = v.pt,
                    Count = v._am or 1
                })
            end
        end
    end
    return Huges
end

function Ghep_pet_len_gold_rainbow(danh_sach_ten_pet)
    for _, ten_pet in ipairs(danh_sach_ten_pet) do
        -- G·ªôp Gold
        local Pet_List1 = Manager:GetPets(ten_pet, nil)
        for _, pet in ipairs(Pet_List1) do
            while pet.Count >= 16 do
                local success, err = pcall(function()
                    game:GetService("ReplicatedStorage").Network.GoldMachine_Activate:InvokeServer(pet.UID, 2)
                end)
                if not success then
                    warn("‚ùå L·ªói khi √©p pet GOLD: " .. tostring(err))
                    break
                end
                task.wait(1)
                pet.Count = pet.Count - 16
            end
        end

        -- G·ªôp Rainbow
        local Pet_List2 = Manager:GetPets(ten_pet, 1)
        for _, pet in ipairs(Pet_List2) do
            while pet.Count >= 16 do
                local success, err = pcall(function()
                    game:GetService("ReplicatedStorage").Network.RainbowMachine_Activate:InvokeServer(pet.UID, 2)
                end)
                if not success then
                    warn("‚ùå L·ªói khi √©p pet RAINBOW: " .. tostring(err))
                    break
                end
                task.wait(1)
                pet.Count = pet.Count - 16
            end
        end
    end
end

-- G·ªçi h√†m √©p nhi·ªÅu pet
Ghep_pet_len_gold_rainbow(NamePet_ep)


end)

--GUI xem all
task.spawn(function()
wait(99)

local CoreGui = game:GetService("CoreGui")

-- T√¨m v√† xo√° TopBarApp
for _, gui in ipairs(CoreGui:GetChildren()) do
    if gui.Name == "TopBarApp" and gui.ClassName == "Folder" then
        pcall(function()
            gui:Destroy()
            print("ƒê√£ xo√°:", gui.Name, "-", gui.ClassName)
        end)
    end
end


-- D·ªãch v·ª• c∆° b·∫£n
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local Save = require(ReplicatedStorage.Library.Client.Save)

-- H√†m format s·ªë l·ªõn th√†nh chu·ªói d·∫°ng 1.23M, 4.56B...
local function Formatint(int)
    local Suffix = {"", "k", "M", "B", "T", "Qd", "Qn", "Sx", "Sp", "Oc", "No", "De", "UDe", "DDe"}
    local Index = 1
    if int < 999 then
        return tostring(int)
    end
    while int >= 1000 and Index < #Suffix do
        int = int / 1000
        Index = Index + 1
    end
    return string.format("%.2f%s", int, Suffix[Index])
end

-- C·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc label theo text
local function updateLabelSize(label)
    label.Size = UDim2.new(0, label.TextBounds.X + 20, 0, 38)
end

-- Ti·ªán √≠ch l·∫•y TimeTrialStats
local function safeFetchSave()
    for i = 1, 3 do
        local ok, data = pcall(Save.Get)
        if ok and data and data.TimeTrialStats then
            return data.TimeTrialStats
        end
        task.wait(1)
    end
    return { DailyRuns = 0, Points = 0 }
end

local function getRunsLeft()
    local stats = safeFetchSave()
    return 10 - (stats.DailyRuns or 0)
end

local function getTimeTrialPoints()
    local stats = safeFetchSave()
    return stats.Points or 0
end

-- L·∫•y s·ªë l∆∞·ª£ng currency theo id
local function getCurrencyAmount(currencyId)
    local Inventory = Save.Get().Inventory
    for _, v in pairs(Inventory.Currency) do
        if v.id == currencyId then
            return v._am or 0
        end
    end
    return 0
end

-- L·∫•y s·ªë l∆∞·ª£ng Lootbox theo id
local function getLootboxAmount(itemId)
    local Inventory = Save.Get().Inventory
    for _, v in pairs(Inventory.Lootbox) do
        if v.id == itemId then
            return tonumber(v._am) or 0
        end
    end
    return 0
end

-- L·∫•y s·ªë l∆∞·ª£ng Misc item theo id
local function getMiscAmount(itemId)
    local Inventory = Save.Get().Inventory
    for _, v in pairs(Inventory.Misc) do
        if v.id == itemId then
            return tonumber(v._am) or 0
        end
    end
    return 0
end

-- H√†m kh·ªüi t·∫°o GUI v√† c·∫≠p nh·∫≠t
local function startGuiUpdater()
    -- Xo√° GUI c≈© n·∫øu ƒë√£ c√≥
    local oldGui = playerGui:FindFirstChild("GuiUpdater")
    if oldGui then oldGui:Destroy() end

    -- T·∫°o ScreenGui m·ªõi
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "GuiUpdater"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = playerGui

    -- T·∫°o khu v·ª±c hi·ªÉn th·ªã
    local function createRegion(position, anchor, alignment)
        local frame = Instance.new("Frame")
        frame.BackgroundTransparency = 1
        frame.Size = UDim2.new(0, 250, 1, 0)
        frame.Position = position
        frame.AnchorPoint = anchor
        frame.Parent = screenGui

        local layout = Instance.new("UIListLayout")
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Padding = UDim.new(0, 0)
        layout.HorizontalAlignment = alignment
        layout.VerticalAlignment = Enum.VerticalAlignment.Top
        layout.Parent = frame

        return frame
    end

    local rightRegion  = createRegion(UDim2.new(1, -30, 0, -10), Vector2.new(1, 0), Enum.HorizontalAlignment.Right)
    local centerRegion = createRegion(UDim2.new(0.5, -10, 0, -10), Vector2.new(0.5, 0), Enum.HorizontalAlignment.Center)
    local leftRegion   = createRegion(UDim2.new(0, 0, 0, -5), Vector2.new(0, 0), Enum.HorizontalAlignment.Left)

    -- T·∫°o Label
    local function createLabel(name, parent, bgColor)
        local label = Instance.new("TextLabel")
        label.Name = name
        label.Size = UDim2.new(1, 0, 0, 38)
        label.BackgroundColor3 = bgColor
        label.TextColor3 = Color3.new(1, 1, 1)
        label.Font = Enum.Font.GothamBold
        label.TextSize = 40
        label.BorderSizePixel = 0
        label.TextXAlignment = Enum.TextXAlignment.Center
        label.AutoLocalize = false
        label.Parent = parent
        return label
    end

    local chanceLabel     = createLabel("ChanceLabel",       rightRegion,   Color3.fromRGB(128, 0, 128))
    local tilesLabel      = createLabel("TilesLabel",        rightRegion,   Color3.fromRGB(128, 0, 128))
    local rebirthLabel    = createLabel("RebirthLabel",      rightRegion,   Color3.fromRGB(128, 0, 128))
    local coinsLabel      = createLabel("CoinsLabel",        rightRegion,   Color3.fromRGB(128, 0, 128))
    --local giftLabel       = createLabel("TropicalGiftLabel", rightRegion,   Color3.fromRGB(128, 0, 128))
    --local ticketLabel     = createLabel("SBPTicketLabel",    rightRegion,   Color3.fromRGB(128, 0, 128))

    local timeTrialLabel  = createLabel("timeTrialLabel",    leftRegion,    Color3.fromRGB(128, 0, 128))
    local pointsLabel     = createLabel("pointsLabel",       centerRegion,  Color3.fromRGB(128, 0, 128))

    -- V√≤ng l·∫∑p c·∫≠p nh·∫≠t GUI li√™n t·ª•c
    while true do
        local currentTime = os.time()
        tilesLabel.Text   = tostring(#game:GetService("Workspace").__THINGS.Tiles:GetChildren()) .. " T"
        updateLabelSize(tilesLabel)

        coinsLabel.Text   = Formatint(getCurrencyAmount("BlockPartyCoins"))
        updateLabelSize(coinsLabel)

        chanceLabel.Text  = tostring(_G.CURRENT_HUGE_CHANCE or 0) .. "X"
        updateLabelSize(chanceLabel)

        rebirthLabel.Text = tostring(Save.Get().TileRebirth or 0) .. "RB"
        updateLabelSize(rebirthLabel)

        --giftLabel.Text    = tostring(getLootboxAmount("Tropical Gift")) .. " | Tropical Gift"
        --updateLabelSize(giftLabel)

        --ticketLabel.Text  = tostring(getMiscAmount("Summer Block Party Ticket")) .. " | Summer Ticket"
        --updateLabelSize(ticketLabel)

        timeTrialLabel.Text = tostring(getRunsLeft())
        updateLabelSize(timeTrialLabel)

        pointsLabel.Text =tostring(getTimeTrialPoints())
        updateLabelSize(pointsLabel)

        task.wait(5)
    end
end

-- B·∫Øt ƒë·∫ßu GUI Updater
startGuiUpdater()




end)

-- gh√©p gift bag v√† m·ªü gift
task.spawn(function()
wait(200)

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SaveData = require(ReplicatedStorage.Library.Client.Save).Get()

local ForgeMachine_Activate = ReplicatedStorage.Network:WaitForChild("ForgeMachine_Activate")
local GiftBag_Open = ReplicatedStorage.Network:WaitForChild("GiftBag_Open")

local GIFT_BAG_NAME = "Gift Bag"
local MIN_REQUIRED = 4
local List_Open_Giftbag = {
    "Mini Chest",
    "Rainbow Mini Chest",
    "Large Gift Bag"
}

local function processGiftBags()
    -- üîÅ Gh√©p Gift Bag th√†nh Large Gift Bag
    do
        local giftBagUID, giftBagAmount = nil, 0
        for uid, data in pairs(SaveData.Inventory["Misc"]) do
            if data.id == GIFT_BAG_NAME then
                giftBagUID = uid
                giftBagAmount = data._am or 1
                break
            end
        end

        if giftBagUID and giftBagAmount >= MIN_REQUIRED then
            local usableAmount = math.floor(giftBagAmount / MIN_REQUIRED) * MIN_REQUIRED
            ForgeMachine_Activate:InvokeServer("Large Gift Bag", {[giftBagUID] = usableAmount})
            task.wait(1.5)
        end
    end

    -- üéÅ M·ªü giftbags
    do
        local inventory = SaveData.Inventory or {}
        local giftbagCounts = {}

        for _, group in pairs(inventory) do
            for _, obj in pairs(group) do
                if obj.id and table.find(List_Open_Giftbag, obj.id) then
                    giftbagCounts[obj.id] = (giftbagCounts[obj.id] or 0) + (obj._am or 1)
                end
            end
        end

        for _, giftName in ipairs(List_Open_Giftbag) do
            local count = giftbagCounts[giftName] or 0
            if count > 0 then
                if giftName == "Large Gift Bag" then
                    if count >= 50 then
                        pcall(function() GiftBag_Open:InvokeServer(giftName, 50) end)
                        count -= 50
                        task.wait(1)
                    end
                    while count >= 10 do
                        pcall(function() GiftBag_Open:InvokeServer(giftName, 10) end)
                        count -= 10
                        task.wait(1)
                    end
                end
                for i = 1, count do
                    pcall(function() GiftBag_Open:InvokeServer(giftName, 1) end)
                    task.wait(1)
                end
            end
        end
    end
end

-- ‚è≥ L·∫∑p l·∫°i m·ªói 3600 gi√¢y (1 ti·∫øng)
while true do
    processGiftBags()
    task.wait(3600)
end


end)

-- Ph√°t hi·ªán nick ch∆∞a max UpgradesOwned
task.spawn(function()
wait(150)

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Save = require(ReplicatedStorage.Library.Client.Save)

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- C√°c ch·ªâ s·ªë v√† c·∫•p t·ªëi ƒëa c·∫ßn ƒë·∫°t
local maxUpgrades = {
    Magnet = 7,
    Drops = 7,
    ["Pet Speed"] = 7,
    ["Tap Damage"] = 8,
    Diamonds = 9,
    Luck = 7,
    Ultimates = 2,
    Walkspeed = 2,
    Coins = 8,
    ["Pet Damage"] = 7,
}

local current = Save.Get().UpgradesOwned or {}
local missingUpgrade = false

for name, maxLevel in pairs(maxUpgrades) do
    local data = current[name]
    local highest = 0
    if data then
        for _, level in pairs(data) do
            if level > highest then
                highest = level
            end
        end
    end

    if highest < maxLevel then
        print("‚ö†Ô∏è Ch∆∞a ƒë·∫°t max: " .. name .. " (" .. highest .. "/" .. maxLevel .. ")")
        missingUpgrade = true
    end
end

-- N·∫øu ch∆∞a ƒë·∫°t max, t·∫°o GUI c·∫£nh b√°o
if missingUpgrade then
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "UpgradesWarning"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = playerGui

    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(0, 120, 0, 30)
    textLabel.Position = UDim2.new(0, 10, 0, 10)
    textLabel.BackgroundColor3 = Color3.new(0.2, 0, 0)
    textLabel.TextColor3 = Color3.new(1, 0, 0)
    textLabel.Text = "Upgrades"
    textLabel.Font = Enum.Font.SourceSansBold
    textLabel.TextSize = 18
    textLabel.BorderSizePixel = 0
    textLabel.Parent = screenGui
end


end)
