repeat task.wait() until game:IsLoaded()
local LocalPlayer = game:GetService('Players').LocalPlayer
repeat task.wait() until not LocalPlayer.PlayerGui:FindFirstChild('__INTRO')

if game.PlaceId ~= 131952481663528 then
    return
end


_G.HW = _G.HW or {}
_G.HW.DebugMode = _G.HW.DebugMode or false
_G.HW.SwapInterval = _G.HW.SwapInterval or 1
_G.HW.ScanDebounce = _G.HW.ScanDebounce or 1
_G.HW.ClaimInterval = _G.HW.ClaimInterval or 5
_G.HW.PlaceEggInterval = _G.HW.PlaceEggInterval or 1
_G.HW.BaseWait = _G.HW.BaseWait or 1
_G.EggPillarCount = _G.EggPillarCount or 1

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")
local player = Players.LocalPlayer
local Network = ReplicatedStorage:WaitForChild("Network")



_G.PillarPets = _G.PillarPets or {}
_G.PillarScanDone = _G.PillarScanDone or false
_G.CurrentPlotId = _G.CurrentPlotId or nil
_G.CurrentPlotCFrame = _G.CurrentPlotCFrame or nil
_G.PillarTotalRateById = _G.PillarTotalRateById or {}
_G.PillarDisplayText = _G.PillarDisplayText or {}
_G.CurrentEggPillars = _G.CurrentEggPillars or {}
_G.WeakestPillarsFixed = _G.WeakestPillarsFixed or nil
_G.TotalRate = _G.TotalRate or 0

local function trim(s) return (s and s:gsub("^%s*(.-)%s*$", "%1")) or "" end
local function safeRequire(path)
    local ok, mod = pcall(function() return require(path) end)
    if ok then return mod end
    return nil
end

local function findPlayerPlot()
    local plotsFolder = workspace:FindFirstChild("__THINGS") and workspace.__THINGS:FindFirstChild("Plots")
    if not plotsFolder then return nil end
    for _, plot in pairs(plotsFolder:GetChildren()) do
        local buildFolder = plot:FindFirstChild("Build")
        if buildFolder and buildFolder:FindFirstChild("Sign") then
            local host = buildFolder.Sign:FindFirstChild("Host")
            if host and host:FindFirstChild("SurfaceGui") then
                local frame = host.SurfaceGui:FindFirstChild("Frame")
                if frame and frame:FindFirstChild("Title") then
                    if string.find(frame.Title.Text or "", player.Name) then
                        return plot
                    end
                end
            end
        end
    end
    return nil
end


task.spawn(function()
    while not _G.CurrentPlotId do
        local plot = findPlayerPlot()
        if plot then
            _G.CurrentPlotId = tonumber(plot.Name)
            local mainPart = plot:FindFirstChild("Main")
            if mainPart and mainPart:IsA("BasePart") then _G.CurrentPlotCFrame = mainPart.CFrame end
            break
        end
        task.wait(_G.HW.BaseWait)
    end
end)

task.spawn(function()
    local p = game.Players.LocalPlayer
    local c = p and (p.Character or p.CharacterAdded:Wait())
    local hrp = c and c:FindFirstChild("HumanoidRootPart")
    local hum = c and c:FindFirstChild("Humanoid")
    if not (hrp and hum) then return end
    pcall(function()
        hum.PlatformStand, hrp.Anchored = true, true
        hrp.CFrame += Vector3.new(math.random(-30,10), -30, math.random(-30,10))
    end)
    local part = Instance.new("Part")
    part.Name, part.Size, part.Anchored, part.CanCollide, part.Transparency =
        "TeleportPlatform", Vector3.new(5,1,5), true, true, 1
    part.CFrame = hrp.CFrame + Vector3.new(0, -5, 0)
    part.Parent = workspace
    _G.TeleDone = true
end)

local debrisFolder
local pillarsCFrames = {}
local scanScheduled = false
local DEBRIS_SCAN_LOCK = false
local function distance(v1, v2) return (v1 - v2).Magnitude end
local MAX_DISTANCE = 3

local function parseRateText(text)
    if not text then return 0 end
    local s = tostring(text):lower()
    s = s:gsub(",", "")
    local mult = 1
    if s:find("k") then mult = 1e3
    elseif s:find("m") then mult = 1e6
    elseif s:find("b") then mult = 1e9 end
    local num = tonumber((s:gsub("[^%d%.]", ""))) or 0
    return num * mult
end

local function findDebrisFolder()
    local f = workspace:FindFirstChild("__DEBRIS") or workspace:FindFirstChild("DEBRIS")
    if f then return f end
    for _, c in pairs(workspace:GetChildren()) do
        if type(c.Name) == "string" and string.match(string.lower(c.Name), "debris") then
            return c
        end
    end
    return nil
end

local function buildPillarsCFrames(plot)
    pillarsCFrames = {}
    local pillarsFolder = plot and plot:FindFirstChild("Interactable") and plot.Interactable:FindFirstChild("Pillars")
    if not pillarsFolder then return end
    for _, pillar in pairs(pillarsFolder:GetChildren()) do
        local baseTrim = pillar:FindFirstChild("BaseTrim")
        if baseTrim and baseTrim:IsA("BasePart") then
            local key = tonumber(pillar.Name) or pillar.Name
            pillarsCFrames[key] = baseTrim.CFrame
        end
    end
end

local previousPetCodes = {}
local function scanDebris()
    if DEBRIS_SCAN_LOCK then return end
    DEBRIS_SCAN_LOCK = true
    _G.PillarPets = {}

    if not debrisFolder then debrisFolder = findDebrisFolder() end
    if not debrisFolder then
        DEBRIS_SCAN_LOCK = false
        return
    end

    local PetByPillar = {}
    for _, petFolder in pairs(debrisFolder:GetChildren()) do
        local rootPart = petFolder:FindFirstChild("RootPart")
        if rootPart and rootPart:IsA("BasePart") then
            local petPos = rootPart.Position
            local nearestName, nearestDist = nil, math.huge
            for pname, pcf in pairs(pillarsCFrames) do
                local d = distance(petPos, pcf.Position)
                if d < nearestDist then nearestDist, nearestName = d, pname end
            end
            if nearestName and nearestDist <= MAX_DISTANCE then
                local displayText, rateText
                for _, d in ipairs(petFolder:GetDescendants()) do
                    if d:IsA("TextLabel") or d:IsA("TextBox") then
                        if not displayText and string.lower(d.Name):find("displayname") then displayText = d.Text end
                        if not rateText and string.lower(d.Name):find("rate") then rateText = d.Text end
                    elseif d:IsA("Frame") then
                        local dn = d:FindFirstChild("DisplayName")
                        local rt = d:FindFirstChild("Rate")
                        if dn and rt and dn:IsA("TextLabel") and rt:IsA("TextLabel") then
                            displayText = displayText or dn.Text
                            rateText = rateText or rt.Text
                            break
                        end
                    end
                end
                if displayText then
                    PetByPillar[nearestName] = PetByPillar[nearestName] or {}
                    table.insert(PetByPillar[nearestName], {
                        Name = displayText,
                        Rate = parseRateText(rateText),
                        CodeName = petFolder.Name
                    })
                end
            end
        end
    end
    for pid, _ in pairs(pillarsCFrames) do
        if not PetByPillar[pid] then PetByPillar[pid] = {} end
    end
    local changed = false
    for pid, pets in pairs(PetByPillar) do
        if not _G.CurrentEggPillars[pid] then
            local codes = {}
            for _, p in ipairs(pets) do table.insert(codes, p.CodeName) end
            table.sort(codes)
            local s = table.concat(codes, ",")
            if previousPetCodes[pid] ~= s then previousPetCodes[pid] = s; changed = true end
        end
    end

    if changed or not next(_G.PillarTotalRateById) then
        _G.PillarPets = PetByPillar
        _G.PillarTotalRateById = _G.PillarTotalRateById or {}
        local totalRate = 0
        for pid, pets in pairs(PetByPillar) do
            if not _G.CurrentEggPillars[pid] then
                local sum = 0
                for _, p in ipairs(pets) do sum = sum + (p.Rate or 0) end
                _G.PillarTotalRateById[pid] = sum
                totalRate = totalRate + sum
            else
                _G.PillarTotalRateById[pid] = _G.PillarTotalRateById[pid] or 0
                totalRate = totalRate + (_G.PillarTotalRateById[pid] or 0)
            end
        end
        _G.TotalRate = totalRate

        _G.PillarDisplayText = {}
        for pid, pets in pairs(_G.PillarPets) do
            if not _G.CurrentEggPillars[pid] then
                if #pets > 0 then
                    local names = {}
                    for _, p in ipairs(pets) do table.insert(names, p.Name) end
                    _G.PillarDisplayText[pid] = ("Pillar %s:\nPet: %s"):format(tostring(pid), table.concat(names, ", "))
                else
                    _G.PillarDisplayText[pid] = ("Pillar %s:\nPet: (trống)"):format(tostring(pid))
                end
            end
        end
    end
    DEBRIS_SCAN_LOCK = false
    _G.PillarScanDone = true
end

local function scheduleScan()
    if scanScheduled then return end
    scanScheduled = true
    task.spawn(function()
        task.wait(_G.HW.ScanDebounce)
        scanScheduled = false
        scanDebris()
    end)
end

task.spawn(function()
    repeat task.wait(_G.HW.BaseWait) until _G.CurrentPlotId and _G.TeleDone
    local plotFolder = workspace:WaitForChild("__THINGS"):WaitForChild("Plots")
    local myPlot = plotFolder:FindFirstChild(tostring(_G.CurrentPlotId))
    if myPlot then buildPillarsCFrames(myPlot) end
    debrisFolder = findDebrisFolder()
    if debrisFolder then
        debrisFolder.ChildAdded:Connect(scheduleScan)
        debrisFolder.ChildRemoved:Connect(scheduleScan)
    end
    scheduleScan()
end)

task.spawn(function()
    task.wait(9)
    local Client = ReplicatedStorage:WaitForChild("Library"):WaitForChild("Client")
    local SaveModule = nil
    while not SaveModule do
        SaveModule = safeRequire(Client.Save)
        if not SaveModule then task.wait(_G.HW.BaseWait) end
    end
    local function getCurrencyAmount(currencyId)
        local ok, data = pcall(function() return SaveModule.Get() end)
        if not ok or not data or not data.Inventory or not data.Inventory.Currency then return 0 end
        for _, v in pairs(data.Inventory.Currency) do
            if v.id == currencyId then return tonumber(v._am) or 0 end
        end
        return 0
    end
    local function rateCategory(totalRate)
        totalRate = tonumber(totalRate) or 0
        if totalRate >= 15000 then
            return 3
        elseif totalRate >= 10000 then
            return 2
        elseif totalRate >= 6000 then
            return 1
        else
            return 0
        end
    end
    local lastTier = nil
    local prevCategory = rateCategory(_G.TotalRate)
    repeat task.wait(_G.HW.BaseWait) until _G.PillarScanDone and _G.TeleDone
    while true do
        local candy = getCurrencyAmount("HalloweenCoins")
        local totalRate = tonumber(_G.TotalRate) or 0
        local currCategory = rateCategory(totalRate)
        if currCategory ~= prevCategory then
            lastTier = nil
        end
        local tier = lastTier or 2
        if totalRate >= 15000 then
            if tier == 5 then
                if candy < 15000000 then tier = 2 end
            else
                if candy >= 90000000 then tier = 5 end
            end
        elseif totalRate >= 10000 then
            if tier == 4 then
                if candy < 2400000 then tier = 3 end
            else
                if candy >= 10500000 then tier = 4 end
            end
        elseif totalRate >= 6000 then
            if tier == 3 then
                if candy < 50000 then tier = 2 end
            else
                if candy >= 500000 then tier = 3 end
            end
        else
            -- totalRate < 6000:
            if candy >= 30000000 then
                tier = 5
            elseif candy >= 5000000 then
                tier = 4
            elseif candy >= 500000 then
                tier = 3
            elseif candy >= 50000 then
                tier = 2
            else
                tier = 2
            end
        end
        lastTier = tier
        prevCategory = currCategory
        pcall(function()
            Network.Plots_Invoke:InvokeServer(_G.CurrentPlotId, "PurchaseEgg", tier, 3)
        end)
        task.wait(1)
    end
end)

task.spawn(function()
    repeat task.wait(_G.HW.BaseWait) until _G.PillarScanDone and _G.TeleDone

    local Client = ReplicatedStorage:WaitForChild("Library"):WaitForChild("Client")
    local SaveModule = safeRequire(Client.Save)
    while not SaveModule do task.wait(_G.HW.BaseWait); SaveModule = safeRequire(Client.Save) end

    local eggPriority = {"Coffin Egg","Reaper Egg","Spider Egg","Cauldron Egg","Ghost Egg","Bat Egg","Grave Egg","Pumpkin Egg"}
    local currentEgg = nil

    while true do
        local ok, saveData = pcall(function() return SaveModule.Get() end)
        if not ok or not saveData or not saveData.Inventory then
            task.wait(_G.HW.BaseWait)
        else
            local eggList = {}
            for _, v in pairs(saveData.Inventory.EggHalloween or {}) do
                if v.id then
                    local amount = (v._am and v._am > 0) and v._am or 1
                    eggList[v.id] = amount
                end
            end
            local bestEgg
            for _, name in ipairs(eggPriority) do if eggList[name] then bestEgg = name break end end
            if bestEgg then
                currentEgg = bestEgg
                for pid, _ in pairs(_G.PillarPets or {}) do _G.PillarTotalRateById[pid] = _G.PillarTotalRateById[pid] or 0 end
                if not _G.WeakestPillarsFixed then
                    local sorted = {}
                    for pid, total in pairs(_G.PillarTotalRateById) do table.insert(sorted, {id = pid, rate = total or 0}) end
                    table.sort(sorted, function(a,b) return a.rate < b.rate end)
                    local weakest = {}
                    for i=1, math.min(_G.EggPillarCount, #sorted) do table.insert(weakest, sorted[i].id) end
                    if #weakest > 0 then
                        _G.CurrentEggPillars = {}
                        for _, id in ipairs(weakest) do _G.CurrentEggPillars[id] = true end
                        _G.WeakestPillarsFixed = weakest
                    end
                end
                local weakest = _G.WeakestPillarsFixed or {}
                if #weakest > 0 then
                    for _, id in ipairs(weakest) do
                        pcall(function()
                            Network.HalloweenWorld_PlaceEgg:InvokeServer(id, currentEgg)
                        end)
                        task.wait(_G.HW.PlaceEggInterval)
                    end
                    for _, id in ipairs(weakest) do pcall(function() Network.HalloweenWorld_PickUp:InvokeServer(id) end); task.wait(_G.HW.BaseWait) end
                end
            else
                task.wait(_G.HW.BaseWait)
            end
        end
        task.wait(_G.HW.BaseWait)
    end
end)

local Rank = {
    ["Pumpkin Dog"] = 1, ["Skeleton Snake"] = 2, ["Zombie Pig"] = 3,
    ["Evil Raven"] = 4, ["Witch Wolf"] = 5, ["Mummy Cow"] = 6,
    ["Frankenpup Dog"] = 7, ["Devil Tasmanian"] = 8, ["Shark Cat"] = 9,
    ["Evil Kitsune"] = 10, ["Skelemelon"] = 11, ["Specter Owl"] = 12,
    ["Hacked Reaper"] = 13, ["Spectral Deer"] = 14, ["Vampire Agony"] = 15,
}
local function getPower(id, pt)
    local base = Rank[id] or 0
    local bonus = (pt or 0) * 3
    return base + bonus
end

local SaveModule = nil
local ClientLib = ReplicatedStorage:WaitForChild("Library"):WaitForChild("Client")
SaveModule = safeRequire(ClientLib.Save)
while not SaveModule do task.wait(_G.HW.BaseWait); SaveModule = safeRequire(ClientLib.Save) end

local function getBestPet()
    local ok, data = pcall(function() return SaveModule.Get() end)
    if not ok or not data or not data.Inventory then return {power=-1}, 0 end
    local Pets = data.Inventory.HPillar or {}
    local best = { power = -1 }
    local count = 0
    for uid, p in pairs(Pets) do
        if p and p.id then
            count = count + 1
            local power = getPower(p.id, p.pt)
            if power > best.power then
                best = { uid = uid, id = p.id, pt = p.pt or 0, _am = p._am or 1, power = power }
            end
        end
    end
    return best, count
end

local function getPillarPetsFromDisplay()
    local pillars = {}
    for name, text in pairs(_G.PillarDisplayText or {}) do
        local petName = text:match("Pet:%s*(.+)")
        if petName then
            petName = trim(petName)
            local pt = 0
            if petName:find("Rainbow") then pt = 2
            elseif petName:find("Golden") or petName:find("⭐") then pt = 1 end
            petName = petName:gsub("Rainbow ", "") :gsub("Golden ", "") :gsub("⭐ ", "") :gsub("🌈 ", "")
            pillars[name] = { id = petName, pt = pt, power = getPower(petName, pt) }
        else
            pillars[name] = { id = "(trống)", pt = 0, power = 0 }
        end
    end
    return pillars
end

local function isEggPillar(pillarName)
    if not _G.WeakestPillarsFixed then return false end
    for _, v in ipairs(_G.WeakestPillarsFixed) do if v == pillarName then return true end end
    return false
end

local function placePet(pillarId, newPetUid)
    if not pillarId or not newPetUid then return false end
    pcall(function() Network.HalloweenWorld_PickUp:InvokeServer(tonumber(pillarId)) end)
    task.wait(_G.HW.BaseWait)
    pcall(function() Network.HalloweenWorld_PlacePet:InvokeServer(tonumber(pillarId), newPetUid) end)
    return true
end

task.spawn(function()
    while not _G.WeakestPillarsFixed do task.wait(_G.HW.BaseWait) end
    while true do
        local best, count = getBestPet()
        if best and best.id then
            local currentPillars = getPillarPetsFromDisplay()
            for pillar, info in pairs(currentPillars) do
                if isEggPillar(pillar) then continue end
                if info.id == "(trống)" or best.power > info.power then
                    placePet(tonumber(pillar), best.uid)
                    task.wait(_G.HW.BaseWait)
                end
            end
        end
        task.wait(_G.HW.SwapInterval)
    end
end)

task.spawn(function()
    repeat task.wait(_G.HW.BaseWait) until _G.TotalRate and _G.TeleDone
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local PlayerSave = require(ReplicatedStorage.Library.Client.Save)
    local Network = ReplicatedStorage:WaitForChild("Network")
    local function craft(recipeIndex)
        local args = {
            [1] = "HalloweenPetCraftingMachine",
            [2] = recipeIndex,
            [3] = {
                ["shiny"] = false,
                ["pt"] = 0
            }
        }
        pcall(function()
            Network:FindFirstChild("HalloweenCraftingMachine_StartCraft"):InvokeServer(unpack(args))
        end)
        task.wait(5)
    end

    local function claimCraft(id)
        local args = { id }
        pcall(function()
            Network:FindFirstChild("HalloweenCraftingMachine_Claim"):InvokeServer(unpack(args))
        end)
        task.wait(5)
    end

    local function getCraftQueue()
        local data = PlayerSave.Get().HalloweenCraftingQueue or {}
        local ids = {}
        for id, v in pairs(data) do
            if v.Result and v.Result.Data and v.Result.Data.id then
                table.insert(ids, id)
            end
        end
        return ids
    end

    while task.wait(5) do
        local rate = _G.TotalRate or 0
        local queue = getCraftQueue()

        if #queue > 0 then
            for _, id in ipairs(queue) do
                claimCraft(id)
            end
        end

        if rate <= 50000 then
            craft(4) craft(3) craft(2) craft(1)
        else
            craft(4)
        end
    end
end)

task.spawn(function()
    repeat task.wait(_G.HW.BaseWait) until _G.TotalRate and _G.TeleDone
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Network = ReplicatedStorage.Network
    local PlayerSave = require(ReplicatedStorage.Library.Client.Save)
    local function getItemIdByName(invType, name)
        local inv = PlayerSave.Get().Inventory[invType]
        if not inv then return nil end
        for uid, data in pairs(inv) do
            if data.id == name then return uid end
        end
    end

    while task.wait(1) do
        local inv = PlayerSave.Get().Inventory
        local eggHave = false
        for _, data in pairs(inv.EggHalloween or {}) do
            if data.id == "Coffin Egg" or data.id == "Reaper Egg" then
                eggHave = true
                break
            end
        end

        local used = false
        if eggHave then
            local luckyEggId = getItemIdByName("Consumable", "Halloween Lucky Egg")
            local trickLuckId = getItemIdByName("Consumable", "Halloween Trick or Treat Luck")

            if luckyEggId then
                pcall(function()
                    Network.Consumables_Consume:InvokeServer(luckyEggId, 1)
                end)
                used = true
                task.wait(1)
            end

            if trickLuckId then
                pcall(function()
                    Network.Consumables_Consume:InvokeServer(trickLuckId, 1)
                end)
                used = true
            end
        end
        task.wait(used and 600 or 1)
    end
end)
