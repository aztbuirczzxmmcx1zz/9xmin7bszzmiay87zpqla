import os
import time
import subprocess
import pyautogui
import re
# Không cần import pygetwindow vì bạn đã chuyển sang dùng click tọa độ để lấy focus

# ==============================================================================
# 1. CẤU HÌNH CHUNG
# ==============================================================================
# --- CẤU HÌNH LDPlayer & Ứng dụng ---
LDPLAYER_MULTIPLAYER_PATH = r"C:\LDPlayer\LDPlayer9\dnmultiplayer.exe"
BACKUP_APP_PATH = r"C:\Users\ADMIN\Desktop\backupldplayer.exe"

# --- PERFORMANCE COUNTER và DELAY ---
DISK_ACTIVITY_COUNTER = r'\LogicalDisk(C:)\% Disk Time'
DISK_ACTIVITY_THRESHOLD = 5.0 # Ngưỡng Disk Time
STARTUP_DELAY_AFTER_BACKUP = 10 # Chờ 10s sau khi chạy Backup
MAX_WAIT_TIME_DISK_CHECK = 3600 # Thời gian chờ tối đa 1 giờ

# --- CẤU HÌNH EMURB ---
EMURB_PATH = r"C:\Users\ADMIN\Downloads\Yummyemu\YummyEmuPlayer\EmuRB.exe" 
# Biến này được yêu cầu dùng từ bên ngoài, nhưng phải định nghĩa để script hoạt động độc lập:
INITIAL_COUNTDOWN_SECONDS = 3 

# ==============================================================================
# 2. CHỨC NĂNG HỖ TRỢ CHUNG
# ==============================================================================
def kill_dnplayer():
    """Đóng tất cả tiến trình dnplayer.exe đang chạy."""
    try:
        subprocess.run(
            ["taskkill", "/IM", "dnplayer.exe", "/F"],
            check=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.STDOUT,
        )
        print("✅ Đã đóng tất cả tiến trình dnplayer.exe (LDPlayer).")
    except subprocess.CalledProcessError:
        print("ℹ️ Không tìm thấy tiến trình dnplayer.exe đang chạy.")
    except Exception as e:
        print(f"❌ Lỗi khi đóng dnplayer.exe: {e}")

def get_performance_counter_value(counter_path):
    """Đọc giá trị % Disk Time từ Performance Counter."""
    cmd = ["typeperf", counter_path, "-sc", "1"]
    try:
        result = subprocess.run(
            cmd, capture_output=True, text=True, encoding="utf-8", errors="ignore", timeout=15 
        )
    except subprocess.TimeoutExpired:
        return None
    
    lines = [line.strip() for line in result.stdout.splitlines() if line.strip()]
    for line in lines:
        m = re.search(r'"(-?\d+\.\d+)"', line)
        if m:
            try:
                return float(m.group(1))
            except ValueError:
                pass
    return None

def open_application(app_path): 
    """Mở ứng dụng và trả về True/False."""
    if not os.path.isfile(app_path):
        print(f"❌ LỖI: Không tìm thấy file ứng dụng tại: {app_path}") 
        return False
    
    subprocess.Popen([app_path], cwd=os.path.dirname(app_path))
    return True

# ==============================================================================
# 3. CHUỖI TỰ ĐỘNG HÓA CHÍNH (LDPlayer & Backup)
# ==============================================================================

def run_automation_sequence():
    
    # --- PHẦN 1: ĐÓNG LDPLAYER & MỞ MULTIPLAYER ---
    print("\n[BƯỚC 0] Đóng các cửa sổ LDPlayer đang hoạt động...")
    kill_dnplayer()
    time.sleep(3) 

    # Mở LDMultiplayer lần đầu
    try:
        print(f"Mở ứng dụng LDMultiplayer: {LDPLAYER_MULTIPLAYER_PATH}")
        subprocess.Popen(LDPLAYER_MULTIPLAYER_PATH)
        time.sleep(5) # Chờ ứng dụng load
    except FileNotFoundError:
        print(f"LỖI: Không tìm thấy đường dẫn ứng dụng: {LDPLAYER_MULTIPLAYER_PATH}")
        return 

    # CHÈN 4 CÚ CLICK MỚI
    CLICK_SEQUENCE_NEW_INSERT = [
        (652, 749), (786, 750), (822, 719), (891, 602)
    ]
    print("\n[PHẦN CHÈN] Thực hiện 4 click mới sau khi mở LDMultiplayer...")
    for i, (x, y) in enumerate(CLICK_SEQUENCE_NEW_INSERT):
        print(f"Click chèn {i+1}: ({x}, {y})")
        pyautogui.click(x, y)
        time.sleep(1) 
    
    # Click theo tọa độ cũ (chuẩn bị sao lưu)
    CLICK_SEQUENCE_OLD = [(779, 744), (824, 569)]
    print("\n[PHẦN CŨ] Thực hiện 2 click chuẩn bị sao lưu...")
    for i, (x, y) in enumerate(CLICK_SEQUENCE_OLD):
        print(f"Click chuẩn bị sao lưu {i+1}: ({x}, {y})")
        pyautogui.click(x, y)
        time.sleep(1) 

    print("Chờ 6 giây trước khi chạy Backup...")
    time.sleep(6)
    
    # --- PHẦN 2: CHẠY BACKUP & KIỂM TRA ĐĨA ---
    backup_process = None
    try:
        print(f"Chạy ứng dụng Backup: {BACKUP_APP_PATH}")
        backup_process = subprocess.Popen(BACKUP_APP_PATH) 
        
        print(f"*** Chờ {STARTUP_DELAY_AFTER_BACKUP} giây để Backup khởi động và bắt đầu ghi đĩa ***")
        time.sleep(STARTUP_DELAY_AFTER_BACKUP)
    except FileNotFoundError:
        print(f"LỖI: Không tìm thấy đường dẫn ứng dụng Backup: {BACKUP_APP_PATH}")
        return
        
    print("\n[PHẦN 3] Bắt đầu vòng lặp kiểm tra hoạt động Đĩa...")
    start_time = time.time()
    
    while time.time() - start_time < MAX_WAIT_TIME_DISK_CHECK:
        disk_time = get_performance_counter_value(DISK_ACTIVITY_COUNTER)
        
        if disk_time is not None:
            print(f"-> % Disk Time hiện tại: {disk_time:.2f}%")
            
            if disk_time < DISK_ACTIVITY_THRESHOLD:
                print(f"--- ĐĨA ỔN ĐỊNH ({disk_time:.2f} < {DISK_ACTIVITY_THRESHOLD}%) - XÁC NHẬN BACKUP HOÀN TẤT ---")
                break
        else:
            print("-> KHÔNG LẤY ĐƯỢC giá trị Disk Time. Chờ 15s...")

        print("Chờ 15 giây...")
        time.sleep(15)

    else:
        print("\nCẢNH BÁO: Đã hết thời gian chờ tối đa (1 giờ).")

    # --- PHẦN 3.5: CHỜ VÀ KIỂM TRA LẠI ĐĨA (Yêu cầu mới) ---
    print("\n[PHẦN 3.5] Chờ 10 giây và kiểm tra Đĩa lần cuối...")
    time.sleep(10) 

    # Thực hiện kiểm tra đĩa lần cuối (Chỉ một lần kiểm tra)
    disk_time = get_performance_counter_value(DISK_ACTIVITY_COUNTER)

    if disk_time is not None and disk_time < DISK_ACTIVITY_THRESHOLD:
        print(f"-> % Disk Time cuối cùng: {disk_time:.2f}% (Ổn định).")
    elif disk_time is not None:
        print(f"-> % Disk Time cuối cùng: {disk_time:.2f}% (Vẫn cao). Tiếp tục đóng ứng dụng.")
    else:
        print("-> Không lấy được giá trị Disk Time lần cuối. Tiếp tục đóng ứng dụng.")
        
    # Đóng ứng dụng Backup
    if backup_process and backup_process.poll() is None:
        print(f"Đóng ứng dụng Backup: {BACKUP_APP_PATH}")
        backup_process.terminate() 
        time.sleep(1)
        if backup_process.poll() is None:
            backup_process.kill() 
            
    # --- PHẦN 4: GỌI LẠI ỨNG DỤNG VÀ CLICK CUỐI CÙNG ---
    print("\n[PHẦN 4] Tiếp tục mở LDMultiplayer và Click cuối cùng (Khởi tạo phiên mới)...")
    
    try:
        print(f"Gọi lại ứng dụng LDMultiplayer: {LDPLAYER_MULTIPLAYER_PATH}")
        subprocess.Popen(LDPLAYER_MULTIPLAYER_PATH)
        time.sleep(5) 
    except FileNotFoundError:
        print(f"LỖI: Không tìm thấy đường dẫn ứng dụng: {LDPLAYER_MULTIPLAYER_PATH}")
        return 

    # Click theo tọa độ mới (Khởi chạy) - Đã thêm 1236, 272
    CLICK_SEQUENCE_FINAL = [(650, 749), (651, 380), (783, 749), (798, 656), (1236, 272)]
    for i, (x, y) in enumerate(CLICK_SEQUENCE_FINAL):
        print(f"Click khởi chạy {i+1}: ({x}, {y})")
        pyautogui.click(x, y)
        time.sleep(1) 

    print("\n[PHẦN 4 KẾT THÚC] Đã hoàn thành quy trình LDPlayer.")


# ==============================================================================
# 4. CHUỖI HÀNH ĐỘNG EMURB MỚI (Dùng PyAutoGUI - Đã cập nhật)
# ==============================================================================

def run_emurb_sequence():
    
    # 1. Chờ countdown ban đầu
    time.sleep(INITIAL_COUNTDOWN_SECONDS) 

    # 2. Mở EmuRB
    if not open_application(EMURB_PATH):
        return

    # 3. Chờ 15s ứng dụng khởi động
    time.sleep(15) 
    
    # Thao tác click để focus (theo tọa độ mới bạn cung cấp)
    pyautogui.click(694, 61)
    time.sleep(2)
    pyautogui.press('enter')
    time.sleep(2)
    pyautogui.click(694, 91)
    time.sleep(2)
    
    # 4. Gửi phím 3 
    pyautogui.press("3")
    time.sleep(2)
    
    # 5. Gửi Enter 
    pyautogui.press('enter')
    
    # 6. Chờ 30s
    time.sleep(30)

    # 7. Gửi Enter
    pyautogui.press('enter')

    # 8. Gửi phím 1
    pyautogui.press("1")
    time.sleep(2)
    
    # Gửi Enter sau khi gửi phím 1
    pyautogui.press('enter') 
    time.sleep(5)
    
    # 9. Click chuột và chờ (Đã chuyển sang double click)
    
    # Double click (744, 699)
    pyautogui.click(744, 699)
    time.sleep(1)
    pyautogui.click(744, 699)
    time.sleep(2)
    
    pyautogui.click(1047, 542)
    time.sleep(30)
    
    # Double click (984, 542)
    pyautogui.click(984, 542)
    time.sleep(2)
    pyautogui.click(984, 542)
    time.sleep(2)
    
    # Double click (1288, 305)
    pyautogui.click(1288, 305)
    time.sleep(2)
    pyautogui.click(1288, 305)
    time.sleep(2)
    
    # 10. Click để focus/chọn cửa sổ (lần 2)
    pyautogui.click(694, 61)
    time.sleep(2)
    pyautogui.click(694, 61)
    time.sleep(2)

    # 11. Gửi phím 2
    pyautogui.press("2")
    time.sleep(1)

    # 12. Gửi Enter
    pyautogui.press('enter')

    print("\n[PHẦN 5 KẾT THÚC] Chuỗi hành động EmuRB đã hoàn tất.")


# ==============================================================================
# MAIN EXECUTION
# ==============================================================================

if __name__ == "__main__":
    
    # Thực thi chuỗi LDPlayer/Backup
    run_automation_sequence()
    
    # Thực thi chuỗi EmuRB mới
    run_emurb_sequence()
    
    print("\n[KẾT THÚC] Toàn bộ quy trình tự động hóa đã hoàn tất.")

